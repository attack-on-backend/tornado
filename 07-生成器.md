# Attack on Tornado - ç”Ÿæˆå™¨ ğŸŒª




<extoc></extoc>

## å‰è¨€

åœ¨ä¸Šä¸€ç« ä¸­ , æˆ‘ä»¬æåˆ°äº†å¯ä»¥é€šè¿‡åç¨‹æ¥é¿å¼€å›è°ƒåœ°ç‹±çš„é—®é¢˜ , æˆ‘ä»¬è¿™ä¸€ç« å…ˆæ”¾ä¸‹å¯¹åç¨‹çš„ç–‘æƒ‘ , å…ˆæ¥èŠä¸€èŠç”Ÿæˆå™¨

ç”Ÿæˆå™¨æ˜¯åœ¨ `Python 2.2, PEP 255` ä¸­é¦–æ¬¡å¼•å…¥çš„ , ç”Ÿæˆå™¨å®ç°äº†è¿­ä»£å™¨åè®® , æ‰€ä»¥æˆ‘ä»¬å¯ä»¥è¯´ç”Ÿæˆå™¨æ˜¯è¿­ä»£å™¨çš„æ„é€ å™¨ , é€šè¿‡ç”Ÿæˆå™¨æˆ‘ä»¬å¯ä»¥åœ¨å¾ªç¯ä¸­è®¡ç®—ä¸‹ä¸€ä¸ªå€¼æ—¶ä¸ä¼šæµªè´¹å†…å­˜ , ä¹Ÿå°±æ˜¯å¯ä»¥ä¸ºæˆ‘ä»¬æä¾›æƒ°æ€§è®¡ç®—

æˆ‘ä»¬æ¥è‡ªå·±å®ç°ä¸€ä¸ª `range` ä¸ºä¾‹ :

éæƒ°æ€§è®¡ç®— , ä¸€æ¬¡æ€§ç”Ÿæˆ , ä½ éœ€è¦æœ‰è¶³å¤Ÿå¤§çš„å†…å­˜å­˜å‚¨ç»“æœåºåˆ—

```python
def eager_range(up_to):
    """Create a list of integers, from 0 to up_to, exclusive."""
    sequence = []
    index = 0
    while index < up_to:
        sequence.append(index)
        index += 1
    return sequence
```

æƒ°æ€§è®¡ç®— , ç”Ÿæˆå™¨æ–¹å¼

```python
def lazy_range(up_to):
    """Generator to return the sequence of integers from 0 to up_to, exclusive."""
    index = 0
    while index < up_to:
        yield index
        index += 1
```

æƒ°æ€§è®¡ç®— , é—­åŒ…æ–¹å¼

```python
def cell_range(up_to):
    """Closure to return the sequence of integers from 0 to up_to, exclusive."""
    index = 0
    def inner():
        nonlocal index
        while index < up_to:
            index += 1
            return index
    return inner
```

å¯¹äºé—­åŒ…è€Œè¨€å®é™…ä¸Šæ˜¯ä¸€æ¬¡è°ƒç”¨å®Œæ¯•çš„æ¦‚å¿µ , è€Œå¯¹äºç”Ÿæˆå™¨è€Œè¨€æ˜¯æš‚åœä»£ç æ‰§è¡Œçš„æ¦‚å¿µ


## PyGenObject

åœ¨ `Python` ä¸­ , ç”Ÿæˆå™¨çš„å®ç°å°±æ˜¯ `PyGenObject` , æˆ‘ä»¬ä»¥ `Python 3.6.3` ä¸ºä¾‹ , æ¥çœ‹çœ‹å®ƒçš„æºä»£ç 

`Include/genobject.h` , 13~33è¡Œ

```C
/* _PyGenObject_HEAD defines the initial segment of generator
   and coroutine objects. */
#define _PyGenObject_HEAD(prefix)                                           \
    PyObject_HEAD                                                           \
    /* Note: gi_frame can be NULL if the generator is "finished" */         \
    /* _frame: PyFrameObject 
        PyFrameObject æ˜¯ Python å¯¹ x86 å¹³å°ä¸Šæ ˆå¸§çš„æ¨¡æ‹Ÿ,
        åŒæ ·ä¹Ÿæ˜¯ Python å­—èŠ‚ç çš„æ‰§è¡Œç¯å¢ƒ, ä¹Ÿå°±æ˜¯å½“å‰çš„ä¸Šä¸‹æ–‡
    */
    struct _frame *prefix##_frame;                                          \
    /* True if generator is being executed. */                              \
    char prefix##_running;     /* è¿è¡ŒçŠ¶æ€ */                                \
    /* The code object backing the generator */                             \
    PyObject *prefix##_code;   /* å­—èŠ‚ç  */                                  \
    /* List of weak reference. */                                           \
    PyObject *prefix##_weakreflist;                                         \
    /* Name of the generator. */                                            \
    PyObject *prefix##_name;                                                \
    /* Qualified name of the generator. */                                  \
    PyObject *prefix##_qualname;

typedef struct {
    /* The gi_ prefix is intended to remind of generator-iterator. */
    _PyGenObject_HEAD(gi)
} PyGenObject;
```

`_frame (PyFrameObject)` å°±æ˜¯ç”Ÿæˆå™¨çš„ä¸Šä¸‹æ–‡ , `Python` åœ¨æ‰§è¡Œæ—¶å®é™…ä¸Šæ˜¯ä¸€æ¡ `PyFrameObject` é“¾ , æ¯ä¸ª `PyFrameObject` å¯¹è±¡ä¸­éƒ½è®°å½•äº†ä¸Šä¸€ä¸ªæ ˆå¸§å¯¹è±¡ã€å­—èŠ‚ç å¯¹è±¡ã€å­—èŠ‚ç æ‰§è¡Œä½ç½®ä½ç½®

`PyGenObject` å¯¹è±¡å¯¹ `PyFrameObject` åšäº†è¿›ä¸€å±‚çš„å°è£… , è¿™æ˜¯ç”±äºç”Ÿæˆå™¨çš„ç‰¹æ®Šæ€§ , å› ä¸º `PyFrameObject` å¯¹è±¡å®é™…ä¸Šæ˜¯ä¸€æ¬¡æ€§çš„ , æ‰€ä»¥å¿…é¡»ç”±å…¶å®ƒå¯¹è±¡ä¹Ÿå°±æ˜¯ `PyGenObject` æ¥ä¿è¯ç”Ÿæˆå™¨çš„æ­£å¸¸è¿è¡Œ

å…³äº `Python` ä¸­å¯¹ x86 å¹³å°æ ˆå¸§çš„æ¨¡æ‹Ÿæˆ‘ä»¬ä¸è¿‡å¤šçš„è¯´æ˜ , å¯è‡ªè¡Œé˜…è¯» `ã€ŠPythonæºç å‰–æï¼šæ·±åº¦æ¢ç´¢åŠ¨æ€è¯­è¨€æ ¸å¿ƒæŠ€æœ¯ã€‹` ä¸€ä¹¦

## send

åœ¨ `Python 2.5, PEP 342` ä¸­ , æ·»åŠ äº†å°†æ•°æ®å‘é€å›æš‚åœçš„ç”Ÿæˆå™¨ä¸­çš„åŠŸèƒ½ , ä¹Ÿå°±æ˜¯ `send` 

```C
static PyObject *
gen_send_ex(PyGenObject *gen, PyObject *arg, int exc, int closing)
{
    /* è·å–å½“å‰çš„çº¿ç¨‹ç¯å¢ƒ */
    PyThreadState *tstate = PyThreadState_GET();
    /* ç…§å½“å½“å‰ç”Ÿæˆå™¨çš„ PyFrameObject å¯¹è±¡ */
    PyFrameObject *f = gen->gi_frame;
    PyObject *result;

    ......

    if (f->f_lasti == -1) {
        /* æœªæ¿€æ´» */
        if (arg && arg != Py_None) {
            char *msg = "can't send non-None value to a "
                        "just-started generator";
            if (PyCoro_CheckExact(gen)) {
                msg = NON_INIT_CORO_MSG;
            }
            else if (PyAsyncGen_CheckExact(gen)) {
                msg = "can't send non-None value to a "
                      "just-started async generator";
            }
            PyErr_SetString(PyExc_TypeError, msg);
            return NULL;
        }
    } else {
        /* Push arg onto the frame's value stack */
        result = arg ? arg : Py_None;
        Py_INCREF(result);  /* å¦‚æœæœ‰å‚æ•°, å°±å°†å…¶å‹å…¥æ ˆä¸­ */
        *(f->f_stacktop++) = result;
    }

    /* Generators always return to their most recent caller, not
     * necessarily their creator. */
    Py_XINCREF(tstate->frame);
    assert(f->f_back == NULL);
    f->f_back = tstate->frame;

    gen->gi_running = 1; /* å°†ç”Ÿæˆå™¨è®¾ç½®ä¸ºè¿è¡ŒçŠ¶æ€ */
    result = PyEval_EvalFrameEx(f, exc); /* è¿è¡Œç”Ÿæˆå™¨ */
    gen->gi_running = 0;

    /* Don't keep the reference to f_back any longer than necessary.  It
     * may keep a chain of frames alive or it could create a reference
     * cycle. */
    assert(f->f_back == tstate->frame);
    Py_CLEAR(f->f_back);

    /* If the generator just returned (as opposed to yielding), signal
     * that the generator is exhausted. */

    ......

    if (!result || f->f_stacktop == NULL) {
        /* generator can't be rerun, so release the frame */
        /* first clean reference cycle through stored exception traceback */
        PyObject *t, *v, *tb;
        t = f->f_exc_type;
        v = f->f_exc_value;
        tb = f->f_exc_traceback;
        f->f_exc_type = NULL;
        f->f_exc_value = NULL;
        f->f_exc_traceback = NULL;
        Py_XDECREF(t);
        Py_XDECREF(v);
        Py_XDECREF(tb);
        gen->gi_frame->f_gen = NULL;
        gen->gi_frame = NULL;
        Py_DECREF(f);
    }

    return result;
}
```

é€šè¿‡ `send` , å°†æ•°æ®å›ä¼ åˆ°æš‚åœçš„ç”Ÿæˆå™¨ , éšåå°†ç”Ÿæˆå™¨ä¸­çš„æ ˆå¸§å¯¹è±¡æŒ‚è½½åˆ°å½“å‰çº¿ç¨‹ä¸Š , æ‰§è¡Œå®Œæ¯•åå†ä»å½“å‰çº¿ç¨‹ä¸Šå¸è½½ , è¿™æ ·å°±å®ç°äº†ç”Ÿæˆå™¨çš„è°ƒç”¨

`send` çš„å‡ºç°ä½¿æˆ‘ä»¬å¯ä»¥è¿›ä¸€æ­¥å¯¹ç”Ÿæˆå™¨è¿›è¡Œæ§åˆ¶

ç”Ÿæˆå™¨çš„å¦ä¸€ç§è°ƒç”¨æ–¹å¼ `next` å®é™…ä¸Šå°±æ˜¯ `send(None)` 

```C
static PyObject *
gen_iternext(PyGenObject *gen)
{
    return gen_send_ex(gen, NULL, 0, 0);
}
```

## yield from

åœ¨ `Python 3.3, PEP 380` , å¢åŠ äº† `yield from` , è®©ä½ å¯ä»¥ä»¥ä¸€ç§å¹²å‡€çš„æ–¹å¼é‡æ„ç”Ÿæˆå™¨ , æˆ–è€…è¯´æ„é€ ç”Ÿæˆå™¨é“¾ 

```python
def lazy_range(up_to):
    """Generator to return the sequence of integers from 0 to up_to, exclusive."""
    index = 0
    def gratuitous_refactor():
        nonlocal index
        while index < up_to:
            yield index
            index += 1
    yield from gratuitous_refactor()
```

ç”Ÿæˆå™¨é“¾

```python
def bottom():
    # Returning the yield lets the value that goes up the call stack to come right back
    # down.
    return (yield 42)

def middle():
    return (yield from bottom())

def top():
    return (yield from middle())

# Get the generator.
gen = top()
value = next(gen)
print(value)  # Prints '42'.
try:
    value = gen.send(value * 2)
except StopIteration as exc:
    value = exc.value
print(value)  # Prints '84'.
```

æœ‰äº†ç”Ÿæˆå™¨çš„åº•å­ , æˆ‘ä»¬å°±å¯ä»¥å±•å¼€åç¨‹ç¯‡ç« äº†

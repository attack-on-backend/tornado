{"./":{"url":"./","title":"ä»‹ç»","keywords":"","body":"Attack on Tornado ğŸŒªï¸ ä»‹ç» ğŸ™ è‡´åŠ›æ„å»ºä¸€ä¸ªé«˜è´¨é‡çš„åç«¯æŠ€æœ¯å›¾è°± è¿™æ˜¯ä¸€ä¸ªæœ‰æ·±åº¦çš„ Tornado ç³»åˆ—åšå®¢ , åœ¨çº¿é˜…è¯» ä½“éªŒæ›´ä¸æ»‘å“Ÿ æœ¬ç›®å½•ä¸‹æºç ç¯å¢ƒ : - asyncio version: 3.4.3 - tornado version: 6.1 ç›®å½• ğŸš€ IOæ¨¡å‹ BIOå®ç° NIOå®ç° IO Multiplexingå®ç° SIGIOå®ç° AIOå®ç° ç”Ÿæˆå™¨ åç¨‹ AIOåç¨‹å®ç° "},"SUMMARY.html":{"url":"SUMMARY.html","title":"ç›®å½•","keywords":"","body":"Attack on Tornado ğŸŒªï¸ ä»‹ç» ç›®å½• IOæ¨¡å‹ BIOå®ç° NIOå®ç° IO-Multiplexingå®ç° SIGIOå®ç° AIOå®ç° ç”Ÿæˆå™¨ åç¨‹ AIOåç¨‹å®ç° asyncio IOLoop "},"01-IOæ¨¡å‹.html":{"url":"01-IOæ¨¡å‹.html","title":"IOæ¨¡å‹","keywords":"","body":"Attack on Tornado - IOæ¨¡å‹ ğŸŒª å‰è¨€ åœ¨å¼€å§‹ä»‹ç»IOæ¨¡å‹ä¹‹å‰ , æˆ‘ä»¬éœ€è¦å¼„æ¸…æ¥šä¸¤ç»„æ¦‚å¿µ é˜»å¡ , éé˜»å¡ , åŒæ­¥ , å¼‚æ­¥ é€šå¸¸æˆ‘ä»¬å®¹æ˜“æŠŠè¿™ä¸¤ç»„æ¦‚å¿µæ··æ·† , æ¯”å¦‚: åŒæ­¥å’Œé˜»å¡åœ¨æˆ‘ä»¬ç¨‹åºæ‰§è¡Œæ—¶å¥½åƒæ˜¯ä¸€æ ·çš„? å¼‚æ­¥å’Œéé˜»å¡ä¹Ÿå¥½åƒæ²¡ä»€ä¹ˆåŒºåˆ« å®é™…ä¸Šè¿™ä¸¤ç»„æ¦‚å¿µ , å¯èƒ½ä»æŸäº›ç°è±¡æ¥è¯´æ˜¯æœ‰ç‚¹ç›¸ä¼¼ , ä½†å®é™…ä¸Šå®ƒä»¬çš„å…³æ³¨ç‚¹å…¶å®æ˜¯ä¸ä¸€æ ·çš„ åŒæ­¥ä¸å¼‚æ­¥ åŒæ­¥å’Œå¼‚æ­¥å…³æ³¨çš„æ˜¯æ¶ˆæ¯é€šä¿¡æœºåˆ¶ , ä¹Ÿå°±æ˜¯åŒæ­¥é€šä¿¡è¿˜æ˜¯å¼‚æ­¥é€šä¿¡ æ‰€è°“åŒæ­¥ , å°±æ˜¯åœ¨å‘å‡ºä¸€ä¸ªåŠŸèƒ½è°ƒç”¨æ—¶ , åœ¨æ²¡æœ‰å¾—åˆ°ç»“æœä¹‹å‰ï¼Œè¯¥è°ƒç”¨å°±ä¸ä¼šè¿”å› . æŒ‰ç…§è¿™ä¸ªå®šä¹‰ï¼Œå…¶å®ç»å¤§å¤šæ•°å‡½æ•°éƒ½æ˜¯åŒæ­¥è°ƒç”¨ . ä½†æ˜¯ä¸€èˆ¬è€Œè¨€ , æˆ‘ä»¬åœ¨è¯´åŒæ­¥ã€å¼‚æ­¥çš„æ—¶å€™ , ç‰¹æŒ‡é‚£äº›éœ€è¦å…¶ä»–éƒ¨ä»¶åä½œæˆ–è€…éœ€è¦ä¸€å®šæ—¶é—´å®Œæˆçš„ä»»åŠ¡ å¼‚æ­¥çš„æ¦‚å¿µå’ŒåŒæ­¥ç›¸å¯¹ , å½“ä¸€ä¸ªå¼‚æ­¥åŠŸèƒ½è°ƒç”¨å‘å‡ºå , è°ƒç”¨è€…ä¸èƒ½ç«‹åˆ»å¾—åˆ°ç»“æœ . å½“è¯¥å¼‚æ­¥åŠŸèƒ½å®Œæˆå , é€šè¿‡çŠ¶æ€ã€é€šçŸ¥æˆ–å›è°ƒæ¥é€šçŸ¥è°ƒç”¨è€… , å¦‚æœå¼‚æ­¥åŠŸèƒ½ç”¨çŠ¶æ€æ¥é€šçŸ¥ , é‚£ä¹ˆè°ƒç”¨è€…å°±éœ€è¦æ¯éš”ä¸€å®šæ—¶é—´æ£€æŸ¥ä¸€æ¬¡ , æ•ˆç‡å°±å¾ˆä½(æœ‰äº›åˆå­¦å¤šçº¿ç¨‹ç¼–ç¨‹çš„äºº , æ€»å–œæ¬¢ç”¨ä¸€ä¸ªå¾ªç¯å»æ£€æŸ¥æŸä¸ªå˜é‡çš„å€¼ , è¿™å…¶å®æ˜¯ä¸€ ç§å¾ˆä¸¥é‡çš„é”™è¯¯) . å¦‚æœæ˜¯ä½¿ç”¨é€šçŸ¥çš„æ–¹å¼ , æ•ˆç‡åˆ™å¾ˆé«˜ , å› ä¸ºå¼‚æ­¥åŠŸèƒ½å‡ ä¹ä¸éœ€è¦åšé¢å¤–çš„æ“ä½œ . è‡³äºå›è°ƒå‡½æ•° , å…¶å®å’Œé€šçŸ¥æ²¡å¤ªå¤šåŒºåˆ« é˜»å¡éé˜»å¡ é˜»å¡å’Œéé˜»å¡å…³æ³¨çš„æ˜¯ç¨‹åºåœ¨ç­‰å¾…è°ƒç”¨ç»“æœæ—¶çš„çŠ¶æ€ é˜»å¡è°ƒç”¨æ˜¯æŒ‡è°ƒç”¨ç»“æœè¿”å›ä¹‹å‰ï¼Œå½“å‰çº¿ç¨‹ä¼šè¢«æŒ‚èµ·ï¼ˆå¦‚é‡åˆ°ioæ“ä½œï¼‰ã€‚å‡½æ•°åªæœ‰åœ¨å¾—åˆ°ç»“æœä¹‹åæ‰ä¼šå°†é˜»å¡çš„çº¿ç¨‹æ¿€æ´»ã€‚æœ‰äººä¹Ÿè®¸ä¼šæŠŠé˜»å¡è°ƒç”¨å’ŒåŒæ­¥è°ƒç”¨ç­‰åŒèµ·æ¥ï¼Œå®é™…ä¸Šä»–æ˜¯ä¸åŒçš„ã€‚å¯¹äºåŒæ­¥è°ƒç”¨æ¥è¯´ï¼Œå¾ˆå¤šæ—¶å€™å½“å‰çº¿ç¨‹è¿˜æ˜¯æ¿€æ´»çš„ï¼Œåªæ˜¯ä»é€»è¾‘ä¸Šå½“å‰å‡½æ•°æ²¡æœ‰è¿”å›è€Œå·² éé˜»å¡å’Œé˜»å¡çš„æ¦‚å¿µç›¸å¯¹åº”ï¼ŒæŒ‡åœ¨ä¸èƒ½ç«‹åˆ»å¾—åˆ°ç»“æœä¹‹å‰ä¹Ÿä¼šç«‹åˆ»è¿”å›ï¼ŒåŒæ—¶è¯¥å‡½æ•°ä¸ä¼šé˜»å¡å½“å‰çº¿ç¨‹ å¼„æ¸…æ¥šè¿™ä¸¤ç»„æ¦‚å¿µæˆ‘ä»¬æ‰èƒ½æ›´å¥½çš„å»ç†è§£æ¥ä¸‹æ¥çš„IOæ¨¡å‹ åœ¨I/Oæµç¨‹ä¸­ , ä¸€èˆ¬å¯ä»¥åˆ†ä¸ºä¸¤ä¸ªé˜¶æ®µ : æ•°æ®å‡†å¤‡é˜¶æ®µ , è¿™ä¸ªé˜¶æ®µéœ€è¦ç­‰å¾…æ¥æ”¶ç½‘ç»œæ•°æ® , å½“æ•°æ®åŒ…åˆ°è¾¾æ—¶ , å†…æ ¸ä¼šå°†æ•°æ®åŒ…æ‹·è´åˆ°å†…æ ¸ç¼“å†²åŒº æ•°æ®æ‹·è´é˜¶æ®µ , è¿™ä¸ªé˜¶æ®µæ•°æ®åŒ…ä¼šä»å†…æ ¸ç¼“å†²åŒºå¤åˆ¶åˆ°æˆ‘ä»¬çš„åº”ç”¨ç¨‹åºç¼“å†²åŒº I/Oæ¨¡å‹çš„å·®å¼‚å°±æ¥è‡ªäºåœ¨è¿™ä¸¤ä¸ªé˜¶æ®µä¸Š , ä¸åŒçš„I/Oæ¨¡å‹æœ‰ä¼šä¸åŒçš„è¡¨ç° é˜»å¡IO åœ¨Linuxä¸­ , é»˜è®¤æƒ…å†µä¸‹æ‰€æœ‰çš„ socket éƒ½æ˜¯é˜»å¡çš„ , æµç¨‹å¦‚ä¸Šå›¾ å½“ç”¨æˆ·è¿›ç¨‹è°ƒç”¨äº† recvfrom è¿™ä¸ªç³»ç»Ÿè°ƒç”¨æ—¶ , kernel å°±è¿›å…¥äº†ç¬¬ä¸€ä¸ªé˜¶æ®µ , è¿™ä¸ªé˜¶æ®µæ•´ä¸ªè¿›ç¨‹ä¼šè¢«é˜»å¡ , kernel ç­‰åˆ°æ•°æ®å‡†å¤‡å¥½äº†ä¹‹å , å°±ä¼šå°†æ•°æ®ä» kernel æ‹·è´åˆ°ç”¨æˆ·å†…å­˜ , ç„¶å kernel è¿”å›ç»“æœ , ç”¨æˆ·è¿›ç¨‹æ‰è§£é™¤é˜»å¡çŠ¶æ€ , ç»§ç»­æ‰§è¡Œ æ‰€ä»¥ , é˜»å¡IOçš„ç‰¹ç‚¹å°±æ˜¯åœ¨IOæ‰§è¡Œçš„ä¸¤ä¸ªé˜¶æ®µç”¨æˆ·è¿›ç¨‹éƒ½è¢«é˜»å¡äº† éé˜»å¡IO å¾ˆæ˜æ˜¾ , é˜»å¡IOå¯¹CPUæ˜¯ä¸€ç§æå¤§çš„æµªè´¹ , å¤§éƒ¨åˆ†æ—¶é—´ç”¨æˆ·è¿›ç¨‹éƒ½æ˜¯é˜»å¡çš„ åœ¨éé˜»å¡IOä¸­ , æˆ‘ä»¬å¯ä»¥å°† socket è®¾ç½®æˆéé˜»å¡ , è€Œç”¨æˆ·è¿›ç¨‹åœ¨è°ƒç”¨ recvfrom æ—¶ , å¦‚æœæ•°æ®æ²¡æœ‰å‡†å¤‡å¥½ , é‚£ä¹ˆç›´æ¥è¿”å›ä¸€ä¸ª error , è¿™æ ·ç”¨æˆ·è¿›ç¨‹å°±çŸ¥é“æ•°æ®è¿˜æ²¡æœ‰å‡†å¤‡å¥½ , äºæ˜¯å®ƒå¯ä»¥å†æ¬¡å‘é€ recvfrom ç³»ç»Ÿè°ƒç”¨ , ç›´åˆ°æ•°æ®å‡†å¤‡å®Œæˆ , è¿™ä¸ªæ—¶å€™ç”¨æˆ·è¿›ç¨‹é˜»å¡ , kernel å¼€å§‹æ‹·è´æ•°æ®åˆ°ç”¨æˆ·ç¨‹åºç¼“å†²åŒº , æ‹·è´å®Œæˆä¹‹åè§£é™¤é˜»å¡ æ‰€ä»¥ , éé˜»å¡IO , ç”¨æˆ·åœ¨æ•°æ®å‡†å¤‡é˜¶æ®µä¼šä¸æ–­çš„è½®è¯¢ kernel , è¿™ä¸ªè¿‡ç¨‹æ˜¯ä¸ä¼šé˜»å¡çš„ , ä½†æ˜¯åœ¨æ•°æ®æ‹·è´é˜¶æ®µ recvfrom ä¾ç„¶æ˜¯é˜»å¡çš„ è™½ç„¶éé˜»å¡IOæ¨¡å‹åœ¨ç¬¬ä¸€é˜¶æ®µä¸ä¼šé˜»å¡äº† , ä½†æ˜¯å¤§é‡çš„ recvfrom ç³»ç»Ÿè°ƒç”¨ä¼šå¤§å¹…åº¦æé«˜ CPU çš„æš‚ç”¨ç‡ , ä¸”å¯èƒ½ä¼šæœ‰å¾ˆå¤šæ— æ•ˆçš„ recvfrom , æ‰€ä»¥éé˜»å¡IOæ¨¡å‹ä¸€èˆ¬ä¸è¢«æ¨è IOå¤šè·¯å¤ç”¨ åœ¨IOå¤šè·¯å¤ç”¨ä¸­ , æˆ‘ä»¬åœ¨è°ƒç”¨ recvfrom ä¹‹å‰ , å…ˆè°ƒç”¨ select , select ä¼šä¸æ–­è½®è¯¢æ‰€ä»¥çš„ socket (socket ä¼šè¢«è®¾ç½®æˆ nonblocking ) , ç›´åˆ° select ä¸­æŸä¸ª socket æœ‰æ•°æ®æ‰è¿”å› , å¦åˆ™å°†ä¼šä¸€ç›´é˜»å¡ ç”¨æˆ·è¿›ç¨‹æ‹¿åˆ°å¯è¯»çš„ socket æ—¶ , æ­¤æ—¶å†å»è°ƒç”¨ recvfrom å°†æ•°æ®å¤åˆ¶åˆ°åº”ç”¨ç¨‹åºç¼“å†²åŒº æ‰€ä»¥ , IOå¤šè·¯å¤ç”¨çš„ç‰¹ç‚¹å°±æ˜¯æé«˜äº† recvfrom çš„æ•ˆç‡ , åªæœ‰å½“æ•°æ®å‡†å¤‡å¥½æ—¶æ‰ä¼šå»è°ƒç”¨ , ä¸è¿‡IOå¤šè·¯å¤ç”¨å¤šå‡ºäº†ä¸€ä¸ª select ç³»ç»Ÿè°ƒç”¨ IOå¤šè·¯å¤ç”¨çš„å…·ä½“å®ç°æœ‰ :select , poll , epoll , kqueue ç­‰ç­‰ ä¿¡å·é©±åŠ¨IO æˆ‘ä»¬çŸ¥é“åœ¨IOå¤šè·¯å¤ç”¨ä¸­ , select è¿˜æ˜¯ä¼šé˜»å¡ç”¨æˆ·è¿›ç¨‹ , è€Œåœ¨ä¿¡å·é©±åŠ¨IOä¸­ , é¦–å…ˆå¼€å¯å¥—æ¥å­—çš„ä¿¡å·é©±åŠ¨åŠŸèƒ½ , ç„¶åä½¿ç”¨ sigaction ç³»ç»Ÿè°ƒç”¨ç»‘å®šä¿¡å·å¤„ç†ç¨‹åº , è¿™ä¸ªç³»ç»Ÿè°ƒç”¨æ˜¯ç«‹å³è¿”å›çš„ å½“æ•°æ®å‡†å¤‡å¥½æ—¶ , å†…æ ¸ä¼šå‘ç”¨æˆ·è¿›ç¨‹å‘é€ SIGIO ä¿¡å· , åº”ç”¨è¿›ç¨‹åœ¨æ¥æ”¶åˆ°ä¿¡å·ä¹‹åå†è°ƒç”¨ recvfrom å°†æ•°æ®ä»å†…æ ¸å¤åˆ¶åˆ°ç”¨æˆ·ç¨‹åºç¼“å†²åŒºä¸­ æ‰€ä»¥ , ä¿¡å·é©±åŠ¨IOçš„ç‰¹ç‚¹å°±æ˜¯åœ¨IOå¤šè·¯å¤ç”¨çš„åŸºç¡€ä¸Š , æŠŠ select è¿™ä¸€ä¸ªé˜»å¡è°ƒç”¨ä¹Ÿå»é™¤äº† , ç¬¬ä¸€é˜¶æ®µå®Œå…¨éé˜»å¡ , å½“ç„¶ç¬¬äºŒé˜¶æ®µè¿˜æ˜¯é˜»å¡çš„ å¼‚æ­¥IO åœ¨ä¸Šé¢æˆ‘ä»¬åˆ†æäº†é˜»å¡IO , éé˜»å¡IO , IOå¤šè·¯å¤ç”¨ , ä¿¡å·é©±åŠ¨IO , å®é™…ä¸Šéƒ½æ²¡æœ‰è§£å†³ç¬¬äºŒé˜¶æ®µçš„é˜»å¡é—®é¢˜ ä¹Ÿå°±æ˜¯è¯´é˜»å¡IO , éé˜»å¡IO , IOå¤šè·¯å¤ç”¨ , ä¿¡å·é©±åŠ¨IO éƒ½å±äºåŒæ­¥IO é‚£å°±æ˜äº†äº† , å¼‚æ­¥IOå°±æ˜¯å®ç°ä¸¤é˜¶æ®µå…¨éƒ¨éé˜»å¡ å½“è¯·æ±‚è¿›ç¨‹å‘èµ·è¯»æ“ä½œæ—¶ , å†…æ ¸ä¼šç«‹åˆ»è¿”å› , ä¸ä¼šé˜»å¡è¯·æ±‚è¿›ç¨‹ , å†…æ ¸åœ¨æ•°æ®å‡†å¤‡å®Œæˆå , ä¼šå°†æ•°æ®æ‹·è´åˆ°ç”¨æˆ·ç¨‹åºç¼“å†²åŒº , å½“æ‰€æœ‰è¿™äº›å·¥ä½œå…¨éƒ¨å®Œæˆ , å†…æ ¸ä¼šé€šçŸ¥è¯·æ±‚è¿›ç¨‹ , IOæ“ä½œå·²å®Œæˆ æ‰€ä»¥ , å¼‚æ­¥IOçš„ç‰¹ç‚¹å°±æ˜¯ä¿¡å·é©±åŠ¨IOæ˜¯é€šçŸ¥ç”¨æˆ·è¿›ç¨‹ç°åœ¨å¯ä»¥å¼€å§‹æ‹·è´äº† , è€Œå¼‚æ­¥IOåˆ™æ˜¯é€šçŸ¥ç”¨æˆ·è¿›ç¨‹å·²ç»æ‹·è´å®Œæˆäº† , å®ç°çœŸæ­£çš„ä¸¤é˜¶æ®µéé˜»å¡ å¼‚æ­¥IOå¥½æ˜¯å¥½ , ä½†æ˜¯å½“å‰Linuxå¯¹å¼‚æ­¥IOçš„æ”¯æŒå¹¶ä¸æˆç†Ÿ , æ›´å¤šçš„è¿˜æ˜¯åŸºäºIOå¤šè·¯å¤ç”¨å»è¾¾åˆ°æˆ‘ä»¬çš„ç”¨æˆ·å±‚å¼‚æ­¥ IOæ¨¡å‹æ¯”è¾ƒ æœ€å , è¿™ä¸ªå›¾å°±éå¸¸çš„ç®€å•äº† åç»­æˆ‘ä»¬æ¥é€šè¿‡ä»£ç å»å®ç°è¿™äº›IOæ¨¡å‹ "},"02-BIOå®ç°.html":{"url":"02-BIOå®ç°.html","title":"BIOå®ç°","keywords":"","body":"Attack on Tornado - BIOå®ç° ğŸŒª å‰è¨€ è¿™ä¸€ç« ä¸­æˆ‘ä»¬æ¥ç”¨ Python å®ç° BIO (Blocking IO) ä¹Ÿå°±æ˜¯é˜»å¡IO BIO å®é™…ä¸Š , é»˜è®¤çš„ socket å°±æ˜¯é˜»å¡çš„ , æ‰€ä»¥æˆ‘ä»¬å¯ä»¥ç›´æ¥è¿™æ ·æ¥å®ç° bio_server.py import socket def server(host, port): sock = socket.socket() sock.bind((host, port)) print('å¯åŠ¨æœåŠ¡ç«¯...') # listen(5) è¡¨ç¤ºå…è®¸ç­‰å¾…çš„æœ€å¤§æ•°é‡ sock.listen(5) conn, addr = sock.accept() # çœŸå®åœºæ™¯ä¸‹å½“ç„¶ä¸ä¼šåªæ¥æ”¶1024ä¸ªå­—èŠ‚çš„æ•°æ®å°±å…³é—­æ‰, è€Œæ˜¯ä¼šæ ¹æ®åŒ…çš„å¤§å°æ¥è¿›è¡Œå¤„ç† data = conn.recv(1024).decode('utf-8') print(data) conn.close() sock.close() print('å…³é—­æœåŠ¡ç«¯...') if __name__ == '__main__': server('localhost', 8888) http_client.py.py import socket import json import datetime def client(host, port): sock = socket.socket() sock.connect((host, port)) data = { 'send_user': 'Lyon', 'send_time': datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S'), 'send_msg': 'BIO test...' } sock.send(json.dumps(data).encode('utf-8')) sock.close() print('å®¢æˆ·ç«¯å‘é€æ•°æ®æˆåŠŸ...') if __name__ == '__main__': client('localhost', 8888) æ¥ä¸‹é‡Œæˆ‘ä»¬è®©æœåŠ¡ç«¯å¯ä»¥ä¸€ç›´ä¸åœçš„è·‘ å¾ªç¯BIO æˆ‘ä»¬å¯ä»¥ç›´æ¥åŠ ä¸€ä¸ªæ­»å¾ªç¯ , è®©æœåŠ¡ç«¯å¯ä»¥ä¸€ç›´ä¸æ–­çš„å¤„ç† , è‡³äºå®¢æˆ·ç«¯æˆ‘ä»¬å¹¶ä¸éœ€è¦æ›´æ”¹ bio_server.py import socket def server(host, port): sock = socket.socket() sock.bind((host, port)) print('å¯åŠ¨æœåŠ¡ç«¯...') # listen(5) è¡¨ç¤ºå…è®¸ç­‰å¾…çš„æœ€å¤§æ•°é‡ sock.listen(5) while True: conn, addr = sock.accept() # çœŸå®åœºæ™¯ä¸‹å½“ç„¶ä¸ä¼šåªæ¥æ”¶1024ä¸ªå­—èŠ‚çš„æ•°æ®å°±å…³é—­æ‰, è€Œæ˜¯ä¼šæ ¹æ®åŒ…çš„å¤§å°æ¥è¿›è¡Œå¤„ç† data = conn.recv(1024).decode('utf-8') print(data) conn.close() sock.close() print('å…³é—­æœåŠ¡ç«¯...') if __name__ == '__main__': server('localhost', 8888) è¿™æ ·å°±å¯ä»¥ä¸æ–­çš„è¿›è¡Œå¤„ç†äº† , ä½†æ˜¯å¦‚æœæˆ‘ä»¬æƒ³è¦åŒæ—¶å¤„ç†å¤šä¸ªå®¢æˆ·ç«¯è¿æ¥è¿™æ˜¯ä¸æ”¯æŒçš„ æ‰€ä»¥æˆ‘ä»¬å¯ä»¥å†è¿›é˜¶ä¸€ä¸‹ , æ¯ä¸€ä¸ªè¿æ¥éƒ½ç”¨ä¸€ä¸ªçº¿ç¨‹å»è¿›è¡Œå¤„ç† , æ¥å®ç°åŒæ—¶å¤„ç†å¤šä¸ªè¿æ¥ å¤šçº¿ç¨‹BIO bio_server.py import socket import threading def handle_conn(conn, addr): # çœŸå®åœºæ™¯ä¸‹å½“ç„¶ä¸ä¼šåªæ¥æ”¶1024ä¸ªå­—èŠ‚çš„æ•°æ®å°±å…³é—­æ‰, è€Œæ˜¯ä¼šæ ¹æ®åŒ…çš„å¤§å°æ¥è¿›è¡Œå¤„ç† data = conn.recv(1024).decode('utf-8') print('çº¿ç¨‹ %s å¤„ç†æ¥è‡ª %s-%s çš„è¿æ¥...' % (threading.currentThread().getName(), addr[0], addr[1])) print(data) conn.close() def server(host, port): sock = socket.socket() sock.bind((host, port)) print('å¯åŠ¨æœåŠ¡ç«¯...') # listen(5) è¡¨ç¤ºå…è®¸ç­‰å¾…çš„æœ€å¤§æ•°é‡ sock.listen(5) while True: conn, addr = sock.accept() print('å®¢æˆ·ç«¯ %s-%s è¿æ¥æˆåŠŸ, ç­‰å¾…å‘é€æ•°æ®...' % (addr[0], addr[1])) handle = threading.Thread(target=handle_conn, args=(conn, addr)) handle.start() sock.close() print('å…³é—­æœåŠ¡ç«¯...') if __name__ == '__main__': server('localhost', 8888) "},"03-NIOå®ç°.html":{"url":"03-NIOå®ç°.html","title":"NIOå®ç°","keywords":"","body":"Attack on Tornado - NIOå®ç° ğŸŒª å‰è¨€ è¿™ä¸€ç« ä¸­æˆ‘ä»¬æ¥ç”¨ Python å®ç° NIO (Non-blocking IO) ä¹Ÿå°±æ˜¯éé˜»å¡IO NIO åœ¨IOæ¨¡å‹çš„è®²è§£ä¸­ , æˆ‘ä»¬å·²ç»çŸ¥é“ , recvfrom ç³»ç»Ÿè°ƒç”¨ä¹‹å , è¿›ç¨‹å¹¶æ²¡æœ‰é˜»å¡ , å†…æ ¸é©¬ä¸Šè¿”å›ç»™è¿›ç¨‹ , å¦‚æœæ•°æ®è¿˜æ²¡å‡†å¤‡å¥½ , æ­¤æ—¶ä¼šè¿”å›ä¸€ä¸ª error è€Œè¿›ç¨‹åœ¨è¿”å›ä¹‹å , å¯ä»¥åšåˆ«çš„äº‹æƒ… , ç„¶åå†å‘èµ· recvfrom ç³»ç»Ÿè°ƒç”¨ , ä¸€ç›´é‡å¤ç›´åˆ°æ‹¿åˆ°æ•°æ®ä¸ºæ­¢ , æ‰€ä»¥æˆ‘ä»¬éœ€è¦ä¸æ–­çš„è¿›è¡Œè½®è¯¢ nio_server.py import socket def server(host, port): sock = socket.socket() # å°†socketè®¾ç½®ä¸ºéé˜»å¡ sock.setblocking(False) sock.bind((host, port)) print('å¯åŠ¨æœåŠ¡ç«¯...') # listen(5) è¡¨ç¤ºå…è®¸ç­‰å¾…çš„æœ€å¤§æ•°é‡ sock.listen(5) conn_queue = [] delete_conn = [] while True: try: # å› ä¸ºsocketè¢«è®¾ç½®æˆäº†éé˜»å¡, æ‰€ä»¥è¿™é‡Œä¸ä¼šé˜»å¡ # ä¸”å½“æ²¡æœ‰è¿æ¥è¿›æ¥æ—¶, è¿™é‡Œä¹Ÿä¼šä¸€ç›´error conn, addr = sock.accept() conn_queue.append((conn, addr)) except BlockingIOError as e: for c in conn_queue: conn, addr = c try: # çœŸå®åœºæ™¯ä¸‹å½“ç„¶ä¸ä¼šåªæ¥æ”¶1024ä¸ªå­—èŠ‚çš„æ•°æ®å°±å…³é—­æ‰, è€Œæ˜¯ä¼šæ ¹æ®åŒ…çš„å¤§å°æ¥è¿›è¡Œå¤„ç† # recvåŒæ ·æ˜¯éé˜»å¡çš„, æ‰€ä»¥ä¹Ÿéœ€è¦æ•æ‰ä¸€ä¸‹BlockingIOError data = conn.recv(1024).decode('utf-8') print(data) delete_conn.append(c) conn.close() except BlockingIOError: pass for c in delete_conn: conn_queue.remove(c) delete_conn = [] sock.close() print('å…³é—­æœåŠ¡ç«¯...') if __name__ == '__main__': server('localhost', 8888) http_client.py.py import socket import json import datetime def client(host, port): sock = socket.socket() sock.connect((host, port)) data = { 'send_user': 'Lyon', 'send_time': datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S'), 'send_msg': 'BIO test...' } sock.send(json.dumps(data).encode('utf-8')) sock.close() print('å®¢æˆ·ç«¯å‘é€æ•°æ®æˆåŠŸ...') if __name__ == '__main__': client('localhost', 8888) å½“ç„¶å…³äºè¿æ¥é˜Ÿåˆ— , æˆ‘ä»¬è¿˜å¯ä»¥è¿›è¡Œä¼˜åŒ– , è¿™é‡Œåªæ˜¯ä¸ºäº†å®ç° , å°±ä¸åšä¼˜åŒ–äº† è¿™æ ·æˆ‘ä»¬å°±å®ç°äº†ä¸€ä¸ª NIO æ¨¡å‹ , ä½†æ˜¯åœ¨æœåŠ¡ç«¯ä¸­ , åªæ˜¯ç­‰å¾…è¯·æ±‚å’Œå‡†å¤‡æ•°æ®æ˜¯éé˜»å¡çš„è€Œå·² , è€Œåœ¨å¤„ç†è¯·æ±‚çš„æ—¶å€™è¿˜æ˜¯é˜»å¡å¤„ç†çš„ , è¿™æ ·çš„è¯å°±å¯¼è‡´åœ¨å¤„ç†è¿æ¥æ—¶ , å°±æ— æ³•å†æ¥å—è¿æ¥äº† , æ‰€ä»¥æˆ‘ä»¬å¯ä»¥å’Œ BIO ä¸€æ ·åˆ©ç”¨å¤šçº¿ç¨‹æ¥å¤„ç†è¿æ¥ å¤šçº¿ç¨‹NIO nio_server.py import socket import threading def handle_conn(conn, addr): while True: try: data = conn.recv(1024).decode('utf-8') print('çº¿ç¨‹ %s å¤„ç†æ¥è‡ª %s-%s çš„è¿æ¥...' % (threading.currentThread().getName(), addr[0], addr[1])) print(data) conn.close() break except BlockingIOError: pass conn.close() def server(host, port): sock = socket.socket() # å°†socketè®¾ç½®ä¸ºéé˜»å¡ sock.setblocking(False) sock.bind((host, port)) print('å¯åŠ¨æœåŠ¡ç«¯...') # listen(5) è¡¨ç¤ºå…è®¸ç­‰å¾…çš„æœ€å¤§æ•°é‡ sock.listen(5) while True: try: # å› ä¸ºsocketè¢«è®¾ç½®æˆäº†éé˜»å¡, æ‰€ä»¥è¿™é‡Œä¸ä¼šé˜»å¡ # ä¸”å½“æ²¡æœ‰è¿æ¥è¿›æ¥æ—¶, è¿™é‡Œä¹Ÿä¼šä¸€ç›´error conn, addr = sock.accept() print('å®¢æˆ·ç«¯ %s-%s è¿æ¥æˆåŠŸ, ç­‰å¾…å‘é€æ•°æ®...' % (addr[0], addr[1])) handle = threading.Thread(target=handle_conn, args=(conn, addr)) handle.start() except BlockingIOError as e: pass sock.close() print('å…³é—­æœåŠ¡ç«¯...') if __name__ == '__main__': server('localhost', 8888) "},"04-IO-Multiplexingå®ç°.html":{"url":"04-IO-Multiplexingå®ç°.html","title":"IO-Multiplexingå®ç°","keywords":"","body":"Attack on Tornado - IO Multiplexingå®ç° ğŸŒª å‰è¨€ è¿™ä¸€ç« ä¸­æˆ‘ä»¬æ¥ç”¨ Python å®ç° IO Multiplexing ä¹Ÿå°±æ˜¯IOå¤šè·¯å¤ç”¨ IO Multiplexing å®ç°IOå¤šè·¯å¤ç”¨éœ€è¦å€ŸåŠ©åˆ° selectors selectors ä¸­ä¸ºæˆ‘ä»¬æä¾›äº† select , poll , epoll , kqueue , devpoll iom_server.py import socket import selectors def server(host, port): sock = socket.socket() sock.bind((host, port)) print('å¯åŠ¨æœåŠ¡ç«¯...') # listen(5) è¡¨ç¤ºå…è®¸ç­‰å¾…çš„æœ€å¤§æ•°é‡ sock.listen(5) # è·å–IOå¤šè·¯å¤ç”¨å™¨, è¿™é‡Œä¼šæ ¹æ®ç³»ç»Ÿé€‰æ‹©ç›¸åº”çš„å¤šè·¯å¤ç”¨å™¨ selector = selectors.DefaultSelector() # å°†socketæ³¨å†Œè¿›å¤šè·¯å¤ç”¨å™¨ selector.register(sock, selectors.EVENT_READ) while True: # è¿›è¡Œselectè°ƒç”¨ ready = selector.select() for r in ready: sock = r[0][0] conn, addr = sock.accept() data = conn.recv(1024).decode('utf-8') print(data) conn.close() sock.close() print('å…³é—­æœåŠ¡ç«¯...') if __name__ == '__main__': server('localhost', 8888) http_client.py.py import socket import json import datetime def client(host, port): sock = socket.socket() sock.connect((host, port)) data = { 'send_user': 'Lyon', 'send_time': datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S'), 'send_msg': 'BIO test...' } sock.send(json.dumps(data).encode('utf-8')) sock.close() print('å®¢æˆ·ç«¯å‘é€æ•°æ®æˆåŠŸ...') if __name__ == '__main__': client('localhost', 8888) å¤šçº¿ç¨‹IO Multiplexing ç›¸ä¿¡ä»å‰é¢çš„å‡ ç¯‡å®ç° , ä½ å·²ç»è½»è½¦ç†Ÿè·¯äº† iom_server.py import socket import selectors import threading def handle_conn(conn, addr): data = conn.recv(1024).decode('utf-8') print('çº¿ç¨‹ %s å¤„ç†æ¥è‡ª %s-%s çš„è¿æ¥...' % (threading.currentThread().getName(), addr[0], addr[1])) print(data) conn.close() def server(host, port): sock = socket.socket() sock.bind((host, port)) print('å¯åŠ¨æœåŠ¡ç«¯...') # listen(5) è¡¨ç¤ºå…è®¸ç­‰å¾…çš„æœ€å¤§æ•°é‡ sock.listen(5) selector = selectors.DefaultSelector() selector.register(sock, selectors.EVENT_READ) while True: ready = selector.select() for r in ready: sock = r[0][0] conn, addr = sock.accept() print('å®¢æˆ·ç«¯ %s-%s è¿æ¥æˆåŠŸ, ç­‰å¾…å‘é€æ•°æ®...' % (addr[0], addr[1])) handle = threading.Thread(target=handle_conn, args=(conn, addr)) handle.start() sock.close() print('å…³é—­æœåŠ¡ç«¯...') if __name__ == '__main__': server('localhost', 8888) "},"05-SIGIOå®ç°.html":{"url":"05-SIGIOå®ç°.html","title":"SIGIOå®ç°","keywords":"","body":"Attack on Tornado - SIGIOå®ç° ğŸŒª å‰è¨€ è¿™ä¸€ç« ä¸­æˆ‘ä»¬æ¥ç”¨ Python å®ç° SIGIO , ä¹Ÿå°±æ˜¯ä¿¡å·é©±åŠ¨IO (Signal driven IO) , æˆ‘ä»¬éœ€è¦å€ŸåŠ©ä¸¤ä¸ªæ ‡å‡†åº“ : signal : ä¿¡å·æ”¯æŒ fcntl : è®¾ç½®éé˜»å¡æ–‡ä»¶æè¿°ç¬¦ å®é™…ä¸Šä¿¡å·é©±åŠ¨IOå¯¹äº TCP å¥—æ¥å­—çš„ä½œç”¨å¹¶ä¸å¤§ , å› ä¸ºåœ¨ TCP ä¸­ SIGIO ä¿¡å·äº§ç”Ÿçš„æ¡ä»¶æœ‰å¾ˆå¤š : ç›‘å¬å¥—æ¥å­—ä¸ŠæŸä¸ªè¿æ¥è¯·æ±‚å·²ç»å®Œæˆ æŸä¸ªæ–­è¿è¯·æ±‚å·²ç»å‘èµ· æŸä¸ªæ–­è¿è¯·æ±‚å·²ç»å®Œæˆ æŸä¸ªè¿æ¥åŠå…³é—­ æ•°æ®åˆ°è¾¾å¥—æ¥å­— æ•°æ®å·²ç»ä»å¥—æ¥å­—å‘é€èµ° å¥—æ¥å­—ä¸Šå‘ç”Ÿå¼‚æ­¥é”™è¯¯ å½“ç„¶æˆ‘ä»¬è¿˜æ˜¯å¯ä»¥é€šè¿‡ SIGIO æ¥ç›‘å¬å¥—æ¥å­— è€Œåœ¨ UDP ä¸­ SIGIO ä¿¡å·äº§ç”Ÿçš„æ¡ä»¶ä»…ä»… : æ•°æ®åˆ°è¾¾å¥—æ¥å­— å¥—æ¥å­—ä¸Šå‘ç”Ÿå¼‚æ­¥é”™è¯¯ UDP SIGIO æˆ‘ä»¬å…ˆæ¥å®ç°ä¸€ä¸ª UDP çš„ SIGIO udp_sigio_server.py import os import time import fcntl import signal import socket def server(host, port): sock = socket.socket(type=socket.SOCK_DGRAM) sock.setblocking(False) sock.bind((host, port)) def receive_signal(signum, stack): data, addr = sock.recvfrom(1024) data = data.decode('utf-8') print(data) signal.signal(signal.SIGIO, receive_signal) fcntl.fcntl(sock.fileno(), fcntl.F_SETOWN, os.getpid()) fcntl.fcntl(sock.fileno(), fcntl.F_SETFL, fcntl.fcntl(sock.fileno(), fcntl.F_GETFL, 0) | fcntl.FASYNC) while True: print('Waiting...') time.sleep(3) if __name__ == '__main__': server('localhost', 8888) http_client.py.py import json import socket import datetime def client(host, port): sock = socket.socket(type=socket.SOCK_DGRAM) data = { 'send_user': 'Lyon', 'send_time': datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S'), 'send_msg': 'BIO test...' } sock.sendto(json.dumps(data).encode('utf-8'), (host, port)) sock.close() print('å®¢æˆ·ç«¯å‘é€æ•°æ®æˆåŠŸ...') if __name__ == '__main__': client('localhost', 8888) TCP SIGIO tcp_sigio_server.py import os import time import fcntl import socket import signal def server(host, port): sock = socket.socket() sock.setblocking(False) sock.bind((host, port)) sock.listen() def receive_signal(signum, stack): try: conn, addr = sock.accept() data = conn.recv(1024).decode('utf-8') print(data) conn.close() except BlockingIOError: pass signal.signal(signal.SIGIO, receive_signal) fcntl.fcntl(sock.fileno(), fcntl.F_SETOWN, os.getpid()) fcntl.fcntl(sock.fileno(), fcntl.F_SETFL, fcntl.fcntl(sock.fileno(), fcntl.F_GETFL, 0) | fcntl.FASYNC) while True: print('Waiting...') time.sleep(3) if __name__ == '__main__': server('localhost', 8888) TODO : å•çº¿ç¨‹ä¸‹å­˜åœ¨é—®é¢˜ , æš‚æ—¶è¿˜æ²¡å¼„æ¸…æ¥š åœ¨ Mac ç¯å¢ƒä¸‹ , å¤šçº¿ç¨‹ç‰ˆæœ¬æš‚æ—¶æ²¡å‘ç°é—®é¢˜ thread_tcp_sigio_server.py import os import time import fcntl import socket import signal import threading def handle_conn(conn, addr): while True: try: data = conn.recv(1024).decode('utf-8') print('çº¿ç¨‹ %s å¤„ç†æ¥è‡ª %s-%s çš„è¿æ¥...' % (threading.currentThread().getName(), addr[0], addr[1])) print(data) conn.close() break except BlockingIOError: pass conn.close() def server(host, port): with socket.socket() as sock: sock.setblocking(False) sock.bind((host, port)) sock.listen() def receive_signal(signum, stack): print('SIGIO...') try: conn, addr = sock.accept() handle = threading.Thread(target=handle_conn, args=(conn, addr)) handle.start() except BlockingIOError: pass signal.signal(signal.SIGIO, receive_signal) fcntl.fcntl(sock.fileno(), fcntl.F_SETOWN, os.getpid()) fcntl.fcntl(sock.fileno(), fcntl.F_SETFL, fcntl.fcntl(sock.fileno(), fcntl.F_GETFL, 0) | fcntl.FASYNC) while True: print('Waiting...') time.sleep(3) if __name__ == '__main__': server('localhost', 8888) tcp_sigio_client.py import socket import json import datetime def client(host, port): sock = socket.socket() sock.connect((host, port)) data = { 'send_user': 'Lyon', 'send_time': datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S'), 'send_msg': 'BIO test...' } sock.send(json.dumps(data).encode('utf-8')) sock.close() print('å®¢æˆ·ç«¯å‘é€æ•°æ®æˆåŠŸ...') if __name__ == '__main__': client('localhost', 8888) "},"06-AIOå®ç°.html":{"url":"06-AIOå®ç°.html","title":"AIOå®ç°","keywords":"","body":"Attack on Tornado - AIOå®ç° ğŸŒª å‰è¨€ åœ¨ä¸Šä¸€ç« ä¸­ , æˆ‘ä»¬å·²ç»çŸ¥é“ä¿¡å·é©±åŠ¨IOå¯¹äºæˆ‘ä»¬çš„ TCP åº”ç”¨æ¥è¯´ , æ”¯æŒå¹¶ä¸æ˜¯å¾ˆå¥½ ä¸”ä¸å¹¸çš„æ˜¯åœ¨ Linux ä¸Šçš„å¼‚æ­¥IOæ”¯æŒå¹¶ä¸æˆç†Ÿ , è™½ç„¶ç›¸å¯¹æ¥è¯´ Windows ä¸Šå¯èƒ½è¦æˆç†Ÿä¸€äº› , ä½†æ˜¯æˆ‘ä»¬çš„æœåŠ¡æ›´å¤šçš„æ˜¯åœ¨ Linux ç¯å¢ƒä¸‹è¿è¡Œ åœ¨ç¬¬4ç« çš„ IO-Multiplexingå®ç° ä¸­ , æˆ‘ä»¬é€šè¿‡ selectors å®ç°äº†åŸºäºäº‹ä»¶çš„å¤„ç†æ–¹å¼ , å®é™…ä¸Š selectors è¿˜æ”¯æŒæ³¨å†Œå›è°ƒå‡½æ•° , ä»¥æ­¤æ¥å®ç°æˆ‘ä»¬åº”ç”¨å±‚çš„å¼‚æ­¥IO æˆ‘ä»¬å°†æ¯ä¸€ä¸ªIOæ“ä½œéƒ½åœ¨å›è°ƒå‡½æ•°ä¸­å®Œæˆ , å½“ä¸€ä¸ªIOäº‹ä»¶å‘ç”Ÿæ—¶ , é€šè¿‡è°ƒç”¨å›è°ƒå‡½æ•° , è¾¾åˆ°å¼‚æ­¥æ‰§è¡Œçš„æ•ˆæœ , ä½†æ˜¯æ³¨æ„è¿™ä¸ªå›è°ƒå¹¶ä¸æ˜¯ç”±æ“ä½œç³»ç»Ÿå®Œæˆçš„ , è€Œæ˜¯ç”±æˆ‘ä»¬çš„åº”ç”¨ç¨‹åºæ¥å®Œæˆçš„ , æ¯•ç«Ÿæˆ‘ä»¬å¹¶ä¸æ˜¯åŸºäºæ“ä½œç³»ç»Ÿçš„å¼‚æ­¥IOæ¥å®ç°çš„ å›è°ƒå‡½æ•° aio_server.py import socket from selectors import DefaultSelector, EVENT_READ def server(host, port): selector = DefaultSelector() sock = socket.socket() sock.bind((host, port)) sock.listen(5) sock.setblocking(False) # å®šä¹‰è¯·æ±‚å›è°ƒ def accept(sock, mask): conn, addr = sock.accept() # å®šä¹‰é“¾æ¥å›è°ƒ def handle_conn(conn, mask): data = conn.recv(1024).decode('utf-8') print(data) conn.close() selector.unregister(conn) selector.register(conn, EVENT_READ, handle_conn) selector.register(sock, EVENT_READ, accept) print('å¯åŠ¨æœåŠ¡ç«¯...') while True: ready = selector.select() for event, mask in ready: callable = event.data callable(event.fileobj, mask) if __name__ == '__main__': server('localhost', 8888) http_client.py import socket import json import datetime def client(host, port): sock = socket.socket() sock.connect((host, port)) data = { 'send_user': 'Lyon', 'send_time': datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S'), 'send_msg': 'BIO test...' } sock.send(json.dumps(data).encode('utf-8')) sock.close() print('å®¢æˆ·ç«¯å‘é€æ•°æ®æˆåŠŸ...') if __name__ == '__main__': client('localhost', 8888) æˆ‘ä»¬é€šè¿‡å›è°ƒçš„æ–¹å¼ , è®©IOæ“ä½œéƒ½å˜æˆäº†å¼‚æ­¥æ“ä½œ , ä½†æ˜¯ recv ä¹Ÿå°±æ˜¯æ•°æ®ä»å†…æ ¸æ‹·è´åˆ°ç¨‹åºä¸­è¿˜æ˜¯åŒæ­¥çš„ å›è°ƒåœ°ç‹± è™½ç„¶é€šè¿‡å›è°ƒå‡½æ•° + IOå¤šè·¯å¤ç”¨å®ç°äº†å¼‚æ­¥IO , ä½†æ˜¯è¿™ç§æ–¹å¼å®é™…ä¸Šå­˜åœ¨ å›è°ƒåœ°ç‹±(callback hell) é—®é¢˜ åœ¨ä¸Šé¢çš„ä»£ç ä¸­ , æˆ‘ä»¬çš„ accept å’Œ handle_conn å·²ç»å‡ºç°äº†ä¸¤å±‚å›è°ƒ , æˆ‘ä»¬å¯ä»¥åŠ å…¥ä¸€äº›ä»£ç æ¥çœ‹çœ‹ aio_callback_server.py import socket from selectors import DefaultSelector, EVENT_READ, EVENT_WRITE def server(host, port): selector = DefaultSelector() sock = socket.socket() sock.bind((host, port)) sock.listen(5) sock.setblocking(False) def accept(sock, mask): print('Accept ...') conn, addr = sock.accept() def connect(conn, mask): print('Connect ...') data = conn.recv(1024).decode('utf-8') def write(conn, mask): print('Write ...') def success(conn, mask): print('Success ...') selector.unregister(conn) conn.close() selector.modify(conn, EVENT_READ, success) selector.modify(conn, EVENT_WRITE, write) conn.send(b'ok') selector.register(conn, EVENT_READ, connect) selector.register(sock, EVENT_READ, accept) print('å¯åŠ¨æœåŠ¡ç«¯...') while True: ready = selector.select() for event, mask in ready: callable = event.data callable(event.fileobj, mask) if __name__ == '__main__': server('localhost', 8888) å†è°ƒæ•´ä¸€ä¸‹å®¢æˆ·ç«¯ aio_callback_client.py import time import json import socket import datetime def client(host, port): sock = socket.socket() sock.connect((host, port)) data = { 'send_user': 'Lyon', 'send_time': datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S'), 'send_msg': 'BIO test...' } sock.send(json.dumps(data).encode('utf-8')) time.sleep(5) sock.send(json.dumps(data).encode('utf-8')) sock.close() print('å®¢æˆ·ç«¯å‘é€æ•°æ®æˆåŠŸ...') if __name__ == '__main__': client('localhost', 8888) æˆ‘ä»¬åªä¸è¿‡æ˜¯åœ¨ä¸€ä¸ªè¯·æ±‚ä¸­å¤šæ·»åŠ äº†å‡ æ¬¡è¯»å†™ , ä»£ç å°±å˜å¾—æœ‰æ„æ€äº† , æˆ‘ä»¬çœç•¥ä¸€äº›æ¥çœ‹çœ‹æœåŠ¡ç«¯æ˜¯ä¸ªä»€ä¹ˆæ ·å­çš„ aio_callback_server.py def accept(sock, mask): print('Accept ...') def connect(conn, mask): print('Connect ...') def write(conn, mask): print('Write ...') def success(conn, mask): print('Success ...') selector.modify(conn, EVENT_READ, success) selector.modify(conn, EVENT_WRITE, write) selector.register(conn, EVENT_READ, connect) selector.register(sock, EVENT_READ, accept) è¿™å°±æ¸…æ™°äº† , å½“å±‚æ¬¡ä¸€æ—¦å˜å¤š , é‚£ä¹ˆå›è°ƒåœ°ç‹±å°±ä¼šçªæ˜¾ , æˆ‘ä»¬çš„ä»£ç å³å°†å¾€éäººç±»çš„æ–¹å‘å‘å±• , è€Œå®é™…æƒ…å†µå°±æ˜¯æˆ‘ä»¬çš„ä¸šåŠ¡ä»£ç é€šå¸¸ä¼´éšç€å¤§é‡çš„ç½‘ç»œIOä¸ç£ç›˜IO , åŸºæœ¬ä¸Šæ— æ³•é¿å…å¤šå±‚æ¬¡æƒ…å†µ æ‰€ä»¥å›è°ƒå®ç°çš„åŸºç¡€ä¸Š , è¡ç”Ÿå‡ºäº†åŸºäºåç¨‹çš„è§£å†³æ–¹æ¡ˆ "},"07-ç”Ÿæˆå™¨.html":{"url":"07-ç”Ÿæˆå™¨.html","title":"ç”Ÿæˆå™¨","keywords":"","body":"Attack on Tornado - ç”Ÿæˆå™¨ ğŸŒª å‰è¨€ åœ¨ä¸Šä¸€ç« ä¸­ , æˆ‘ä»¬æåˆ°äº†å¯ä»¥é€šè¿‡åç¨‹æ¥é¿å¼€å›è°ƒåœ°ç‹±çš„é—®é¢˜ , æˆ‘ä»¬è¿™ä¸€ç« å…ˆæ”¾ä¸‹å¯¹åç¨‹çš„ç–‘æƒ‘ , å…ˆæ¥èŠä¸€èŠç”Ÿæˆå™¨ ç”Ÿæˆå™¨æ˜¯åœ¨ Python 2.2, PEP 255 ä¸­é¦–æ¬¡å¼•å…¥çš„ , ç”Ÿæˆå™¨å®ç°äº†è¿­ä»£å™¨åè®® , æ‰€ä»¥æˆ‘ä»¬å¯ä»¥è¯´ç”Ÿæˆå™¨æ˜¯è¿­ä»£å™¨çš„æ„é€ å™¨ , é€šè¿‡ç”Ÿæˆå™¨æˆ‘ä»¬å¯ä»¥åœ¨å¾ªç¯ä¸­è®¡ç®—ä¸‹ä¸€ä¸ªå€¼æ—¶ä¸ä¼šæµªè´¹å†…å­˜ , ä¹Ÿå°±æ˜¯å¯ä»¥ä¸ºæˆ‘ä»¬æä¾›æƒ°æ€§è®¡ç®— æˆ‘ä»¬æ¥è‡ªå·±å®ç°ä¸€ä¸ª range ä¸ºä¾‹ : éæƒ°æ€§è®¡ç®— , ä¸€æ¬¡æ€§ç”Ÿæˆ , ä½ éœ€è¦æœ‰è¶³å¤Ÿå¤§çš„å†…å­˜å­˜å‚¨ç»“æœåºåˆ— def eager_range(up_to): \"\"\"Create a list of integers, from 0 to up_to, exclusive.\"\"\" sequence = [] index = 0 while index æƒ°æ€§è®¡ç®— , ç”Ÿæˆå™¨æ–¹å¼ def lazy_range(up_to): \"\"\"Generator to return the sequence of integers from 0 to up_to, exclusive.\"\"\" index = 0 while index æƒ°æ€§è®¡ç®— , é—­åŒ…æ–¹å¼ def cell_range(up_to): \"\"\"Closure to return the sequence of integers from 0 to up_to, exclusive.\"\"\" index = 0 def inner(): nonlocal index while index å¯¹äºé—­åŒ…è€Œè¨€å®é™…ä¸Šæ˜¯ä¸€æ¬¡è°ƒç”¨å®Œæ¯•çš„æ¦‚å¿µ , è€Œå¯¹äºç”Ÿæˆå™¨è€Œè¨€æ˜¯æš‚åœä»£ç æ‰§è¡Œçš„æ¦‚å¿µ PyGenObject åœ¨ Python ä¸­ , ç”Ÿæˆå™¨çš„å®ç°å°±æ˜¯ PyGenObject , æˆ‘ä»¬ä»¥ Python 3.6.3 ä¸ºä¾‹ , æ¥çœ‹çœ‹å®ƒçš„æºä»£ç  Include/genobject.h , 13~33è¡Œ /* _PyGenObject_HEAD defines the initial segment of generator and coroutine objects. */ #define _PyGenObject_HEAD(prefix) \\ PyObject_HEAD \\ /* Note: gi_frame can be NULL if the generator is \"finished\" */ \\ /* _frame: PyFrameObject PyFrameObject æ˜¯ Python å¯¹ x86 å¹³å°ä¸Šæ ˆå¸§çš„æ¨¡æ‹Ÿ, åŒæ ·ä¹Ÿæ˜¯ Python å­—èŠ‚ç çš„æ‰§è¡Œç¯å¢ƒ, ä¹Ÿå°±æ˜¯å½“å‰çš„ä¸Šä¸‹æ–‡ */ struct _frame *prefix##_frame; \\ /* True if generator is being executed. */ \\ char prefix##_running; /* è¿è¡ŒçŠ¶æ€ */ \\ /* The code object backing the generator */ \\ PyObject *prefix##_code; /* å­—èŠ‚ç  */ \\ /* List of weak reference. */ \\ PyObject *prefix##_weakreflist; \\ /* Name of the generator. */ \\ PyObject *prefix##_name; \\ /* Qualified name of the generator. */ \\ PyObject *prefix##_qualname; typedef struct { /* The gi_ prefix is intended to remind of generator-iterator. */ _PyGenObject_HEAD(gi) } PyGenObject; _frame (PyFrameObject) å°±æ˜¯ç”Ÿæˆå™¨çš„ä¸Šä¸‹æ–‡ , Python åœ¨æ‰§è¡Œæ—¶å®é™…ä¸Šæ˜¯ä¸€æ¡ PyFrameObject é“¾ , æ¯ä¸ª PyFrameObject å¯¹è±¡ä¸­éƒ½è®°å½•äº†ä¸Šä¸€ä¸ªæ ˆå¸§å¯¹è±¡ã€å­—èŠ‚ç å¯¹è±¡ã€å­—èŠ‚ç æ‰§è¡Œä½ç½®ä½ç½® PyGenObject å¯¹è±¡å¯¹ PyFrameObject åšäº†è¿›ä¸€å±‚çš„å°è£… , è¿™æ˜¯ç”±äºç”Ÿæˆå™¨çš„ç‰¹æ®Šæ€§ , å› ä¸º PyFrameObject å¯¹è±¡å®é™…ä¸Šæ˜¯ä¸€æ¬¡æ€§çš„ , æ‰€ä»¥å¿…é¡»ç”±å…¶å®ƒå¯¹è±¡ä¹Ÿå°±æ˜¯ PyGenObject æ¥ä¿è¯ç”Ÿæˆå™¨çš„æ­£å¸¸è¿è¡Œ å…³äº Python ä¸­å¯¹ x86 å¹³å°æ ˆå¸§çš„æ¨¡æ‹Ÿæˆ‘ä»¬ä¸è¿‡å¤šçš„è¯´æ˜ , å¯è‡ªè¡Œé˜…è¯» ã€ŠPythonæºç å‰–æï¼šæ·±åº¦æ¢ç´¢åŠ¨æ€è¯­è¨€æ ¸å¿ƒæŠ€æœ¯ã€‹ ä¸€ä¹¦ send åœ¨ Python 2.5, PEP 342 ä¸­ , æ·»åŠ äº†å°†æ•°æ®å‘é€å›æš‚åœçš„ç”Ÿæˆå™¨ä¸­çš„åŠŸèƒ½ , ä¹Ÿå°±æ˜¯ send static PyObject * gen_send_ex(PyGenObject *gen, PyObject *arg, int exc, int closing) { /* è·å–å½“å‰çš„çº¿ç¨‹ç¯å¢ƒ */ PyThreadState *tstate = PyThreadState_GET(); /* ç…§å½“å½“å‰ç”Ÿæˆå™¨çš„ PyFrameObject å¯¹è±¡ */ PyFrameObject *f = gen->gi_frame; PyObject *result; ...... if (f->f_lasti == -1) { /* æœªæ¿€æ´» */ if (arg && arg != Py_None) { char *msg = \"can't send non-None value to a \" \"just-started generator\"; if (PyCoro_CheckExact(gen)) { msg = NON_INIT_CORO_MSG; } else if (PyAsyncGen_CheckExact(gen)) { msg = \"can't send non-None value to a \" \"just-started async generator\"; } PyErr_SetString(PyExc_TypeError, msg); return NULL; } } else { /* Push arg onto the frame's value stack */ result = arg ? arg : Py_None; Py_INCREF(result); /* å¦‚æœæœ‰å‚æ•°, å°±å°†å…¶å‹å…¥æ ˆä¸­ */ *(f->f_stacktop++) = result; } /* Generators always return to their most recent caller, not * necessarily their creator. */ Py_XINCREF(tstate->frame); assert(f->f_back == NULL); f->f_back = tstate->frame; gen->gi_running = 1; /* å°†ç”Ÿæˆå™¨è®¾ç½®ä¸ºè¿è¡ŒçŠ¶æ€ */ result = PyEval_EvalFrameEx(f, exc); /* è¿è¡Œç”Ÿæˆå™¨ */ gen->gi_running = 0; /* Don't keep the reference to f_back any longer than necessary. It * may keep a chain of frames alive or it could create a reference * cycle. */ assert(f->f_back == tstate->frame); Py_CLEAR(f->f_back); /* If the generator just returned (as opposed to yielding), signal * that the generator is exhausted. */ ...... if (!result || f->f_stacktop == NULL) { /* generator can't be rerun, so release the frame */ /* first clean reference cycle through stored exception traceback */ PyObject *t, *v, *tb; t = f->f_exc_type; v = f->f_exc_value; tb = f->f_exc_traceback; f->f_exc_type = NULL; f->f_exc_value = NULL; f->f_exc_traceback = NULL; Py_XDECREF(t); Py_XDECREF(v); Py_XDECREF(tb); gen->gi_frame->f_gen = NULL; gen->gi_frame = NULL; Py_DECREF(f); } return result; } é€šè¿‡ send , å°†æ•°æ®å›ä¼ åˆ°æš‚åœçš„ç”Ÿæˆå™¨ , éšåå°†ç”Ÿæˆå™¨ä¸­çš„æ ˆå¸§å¯¹è±¡æŒ‚è½½åˆ°å½“å‰çº¿ç¨‹ä¸Š , æ‰§è¡Œå®Œæ¯•åå†ä»å½“å‰çº¿ç¨‹ä¸Šå¸è½½ , è¿™æ ·å°±å®ç°äº†ç”Ÿæˆå™¨çš„è°ƒç”¨ send çš„å‡ºç°ä½¿æˆ‘ä»¬å¯ä»¥è¿›ä¸€æ­¥å¯¹ç”Ÿæˆå™¨è¿›è¡Œæ§åˆ¶ ç”Ÿæˆå™¨çš„å¦ä¸€ç§è°ƒç”¨æ–¹å¼ next å®é™…ä¸Šå°±æ˜¯ send(None) static PyObject * gen_iternext(PyGenObject *gen) { return gen_send_ex(gen, NULL, 0, 0); } yield from åœ¨ Python 3.3, PEP 380 , å¢åŠ äº† yield from , è®©ä½ å¯ä»¥ä»¥ä¸€ç§å¹²å‡€çš„æ–¹å¼é‡æ„ç”Ÿæˆå™¨ , æˆ–è€…è¯´æ„é€ ç”Ÿæˆå™¨é“¾ def lazy_range(up_to): \"\"\"Generator to return the sequence of integers from 0 to up_to, exclusive.\"\"\" index = 0 def gratuitous_refactor(): nonlocal index while index ç”Ÿæˆå™¨é“¾ def bottom(): # Returning the yield lets the value that goes up the call stack to come right back # down. return (yield 42) def middle(): return (yield from bottom()) def top(): return (yield from middle()) # Get the generator. gen = top() value = next(gen) print(value) # Prints '42'. try: value = gen.send(value * 2) except StopIteration as exc: value = exc.value print(value) # Prints '84'. æœ‰äº†ç”Ÿæˆå™¨çš„åº•å­ , æˆ‘ä»¬å°±å¯ä»¥å±•å¼€åç¨‹ç¯‡ç« äº† "},"08-åç¨‹.html":{"url":"08-åç¨‹.html","title":"åç¨‹","keywords":"","body":"Attack on Tornado - åç¨‹ ğŸŒª å‰è¨€ åç¨‹å…¶å®æ¯”çº¿ç¨‹æ›´ä¸ºå¤è€ , é‚£æ—¶å€™åªæœ‰ä¸€ä¸ªCPUåœ¨æ‰§è¡Œä»»åŠ¡ , ä¸ºäº†å®ç°åœ¨ä¸€ä¸ªæ ¸å¿ƒä¸Šçš„å¹¶å‘ , å°±æœ‰äº†åç¨‹ ; è€Œè¦æ”¯æŒå¹¶å‘ , é‚£å°±å¿…é¡»å°†ä»»åŠ¡æ‹†åˆ†æˆå¤šä»»åŠ¡ , å†å°†è¿™äº›ä»»åŠ¡æŒ‰ç…§æŸç§é¡ºåºåˆå¹¶æˆä¸€æ¡æ–°çš„æ—¶é—´æ‰§è¡Œçº¿ , è¿™æ­£æ˜¯å¼‚æ­¥ç¨‹åº å¼‚æ­¥æ˜¯å®ç°å¹¶å‘çš„ä¸€ç§æ–¹å¼ , å®ç°å¹¶å‘çš„æ–¹å¼ä¹Ÿä¸ä»…ä»…åªæœ‰å¼‚æ­¥ä¸€ç§ , æˆ‘ä»¬åœ¨è¿™é‡Œåªé’ˆå¯¹å•çº¿ç¨‹ä»¥åŠåç¨‹å±•å¼€ åç¨‹(Coroutine) , å°±æ˜¯ä¸€ç»„å¯ä»¥ååŒå·¥ä½œ (åä½œå¼) çš„å­ç¨‹åº , åç¨‹å®é™…ä¸Šæ˜¯ä¸€ä¸ªå¾ˆæ™®é€šçš„å‡½æ•° , æˆ–è€…ä¸€ä¸ªä»£ç å— , æˆ–è€…å­è¿‡ç¨‹ , å†æˆ–è€…è¯´åç¨‹å°±æ˜¯ä½ å¯ä»¥æš‚åœæ‰§è¡Œçš„å‡½æ•° åœ¨ Python ä¸­ , å¯ä»¥æš‚åœæ‰§è¡Œçš„å‡½æ•°å°±æ˜¯ç”Ÿæˆå™¨å‡½æ•° , ä¹Ÿå°±æ˜¯ä½¿ç”¨äº† yield å…³é”®å­—çš„å‡½æ•° , ä½†è¿™ä¸ä»£è¡¨ç”Ÿæˆå™¨å°±æ˜¯åç¨‹ , åªèƒ½è¯´ç”Ÿæˆå™¨å¯ä»¥ä½œä¸ºåç¨‹ä½¿ç”¨ , å…³äºè¿™ä¸€ç‚¹ä½ å¯ä»¥åœ¨ã€Šæµç•…çš„Pythonã€‹ç¬¬16ç« -åç¨‹ç¯‡æ‰¾åˆ°ç­”æ¡ˆ ç”Ÿæˆå™¨åªèƒ½æŠŠæ§åˆ¶æƒè½¬äº¤ç»™è°ƒç”¨ç”Ÿæˆå™¨çš„è°ƒç”¨è€… , è€Œåç¨‹è®²ç©¶çš„æ˜¯å¤šä»»åŠ¡åä½œ , åç¨‹å¯ä»¥å°†æ‰§è¡Œæƒäº¤ç»™å…¶ä»–åç¨‹ ; ç”Ÿæˆå™¨ç”¨äºç”Ÿäº§æ•°æ® , åç¨‹æ¶ˆè´¹æ•°æ® , ä¸”åç¨‹ä¸è¿­ä»£æ— å…³ ; ç”Ÿæˆå™¨å®é™…ä¸Šå±äºåç¨‹çš„å­é›† , æ‰€ä»¥ç”Ÿæˆå™¨ä¹Ÿå«åš \"åŠåç¨‹\" åç¨‹ åœ¨ä¸Šä¸€ç¯‡ã€Šç”Ÿæˆå™¨ã€‹ä¸­æˆ‘ä»¬äº†è§£äº† Python ä¸­ç”Ÿæˆå™¨çš„å‘å±• , å®é™…ä¸Šè¿™ä¸ä»…ä»…æ˜¯ç”Ÿæˆå™¨çš„å‘å±• , ä¹Ÿæ˜¯åç¨‹çš„è¿›æ­¥ ä»æœ€åˆæˆ‘ä»¬ä½¿ç”¨ yield æ„å»ºå¯ä¸­æ–­å‡½æ•° , å†åˆ° send å¯ä»¥è°ƒåº¦ç”Ÿæˆå™¨å‡½æ•° , å†åˆ° yield from å¯ä»¥æ„å»ºç”Ÿæˆå™¨è°ƒç”¨é“¾ (è¿™ä¸ªè°ƒç”¨é“¾è‡³å…³é‡è¦ , å› ä¸º send åªæ˜¯å‘é€æ•°æ® , è€Œ yield from å¯ä»¥ç›´æ¥è°ƒåº¦å…¶ä»–ç”Ÿæˆå™¨) æ‹¥æœ‰äº†è¿™äº›åŸºç¡€ , åç¨‹çš„å®ç°å°±å˜å¾—ç®€å•äº†èµ·æ¥ æˆ‘ä»¬å…ˆæ¥çœ‹ä¸¤æ®µä»£ç  : import queue def task(name, work_queue): if work_queue.empty(): print(f\"Task {name} nothing to do\") else: while not work_queue.empty(): count = work_queue.get() total = 0 print(f\"Task {name} running\") for x in range(count): total += 1 print(f\"Task {name} total: {total}\") def main(): \"\"\" This is the main entry point for the program \"\"\" # Create the queue of work work_queue = queue.Queue() # Put some work in the queue for work in [15, 10, 5, 2]: work_queue.put(work) # Create some synchronous tasks tasks = [(task, \"One\", work_queue), (task, \"Two\", work_queue)] # Run the tasks for t, n, q in tasks: t(n, q) if __name__ == \"__main__\": main() è¿è¡Œç»“æœ : Task One running Task One total: 15 Task One running Task One total: 10 Task One running Task One total: 5 Task One running Task One total: 2 Task Two nothing to do æ¥ä¸‹æ¥æˆ‘ä»¬ä½¿ç”¨ yield æ¥æ”¹é€ ä¸€ä¸‹ : import queue def task(name, queue): while not queue.empty(): count = queue.get() total = 0 print(f\"Task {name} running\") for x in range(count): total += 1 yield print(f\"Task {name} total: {total}\") def main(): \"\"\" This is the main entry point for the program \"\"\" # Create the queue of work work_queue = queue.Queue() # Put some work in the queue for work in [15, 10, 5, 2]: work_queue.put(work) # Create some tasks tasks = [task(\"One\", work_queue), task(\"Two\", work_queue)] # Run the tasks done = False while not done: for t in tasks: try: next(t) except StopIteration: tasks.remove(t) if len(tasks) == 0: done = True if __name__ == \"__main__\": main() è¿è¡Œç»“æœ : Task One running Task Two running Task Two total: 10 Task Two running Task One total: 15 Task One running Task Two total: 5 Task One total: 2 åŒæ ·æ˜¯ä¸¤ä¸ª task , åœ¨ç¬¬äºŒæ®µä»£ç ä¸­æˆ‘ä»¬å®ç°äº†å¼‚æ­¥æ‰§è¡Œ , ä¸¤ä¸ª task äº¤å‰åä½œå®Œæˆä»»åŠ¡ , è¿™ä¸¤ä¸ª task å°±æ˜¯ä¸¤ä¸ªåç¨‹ ä¸éš¾å‘ç° , å³ä½¿æˆ‘ä»¬ä¸ç”¨ yield , æˆ‘ä»¬è‡ªå·±é€šè¿‡å‡½æ•°ä¹Ÿå¯ä»¥å®ç°è¿™æ ·çš„å¹¶å‘æ•ˆæœ , æŠŠä¸Šé¢çš„ä»£ç æŒ‰ç…§ yield æ‹†åˆ†æˆå‡ ä¸ªå‡½æ•°åŠŸèƒ½ä¸Šæ˜¯ä¸€æ ·çš„ , æˆ‘ä»¬æŠŠæ‹†åˆ†çš„å‡½æ•°å«åšå­ä¾‹ç¨‹ , å®é™…ä¸Š , å­ä¾‹ç¨‹å¯ä»¥çœ‹åšæ˜¯ç‰¹å®šçŠ¶æ€çš„åç¨‹ , ä»»ä½•çš„å­ä¾‹ç¨‹éƒ½å¯ä»¥è½¬å†™æˆä¸ä½¿ç”¨ yield çš„åç¨‹ å­ä¾‹ç¨‹ä¸åç¨‹ ç›¸å¯¹äºå­ä¾‹ç¨‹è€Œè¨€ , åç¨‹æ›´åŠ çµæ´» , åç¨‹æ›´åŠ é€‚åˆç”¨æ¥å®ç°å½¼æ­¤æ¯”è¾ƒç†Ÿæ‚‰çš„ç¨‹åºç»„ä»¶ , æˆ–è€…è¯´è€¦åˆåº¦é«˜ä¸€ç‚¹çš„ç»„ä»¶ åç¨‹çš„åˆ‡æ¢æ¦‚å¿µæ˜¯ \"è®©æ­¥\" , è€Œå­ä¾‹ç¨‹çš„åˆ‡æ¢æ¦‚å¿µæ˜¯ \"å‡ºäº§\" , ä¸€ä¸ªä¸»åŠ¨ , ä¸€ä¸ªè¢«åŠ¨ , ä»¥ä¸‹æ‘˜è‡ª Wiki : å­ä¾‹ç¨‹å¯ä»¥è°ƒç”¨å…¶ä»–å­ä¾‹ç¨‹ , è°ƒç”¨è€…ç­‰å¾…è¢«è°ƒç”¨è€…ç»“æŸåç»§ç»­æ‰§è¡Œ , æ•…è€Œå­ä¾‹ç¨‹çš„ç”Ÿå‘½æœŸéµå¾ªåè¿›å…ˆå‡º , å³æœ€åä¸€ä¸ªè¢«è°ƒç”¨çš„å­ä¾‹ç¨‹æœ€å…ˆç»“æŸè¿”å› , åç¨‹çš„ç”Ÿå‘½æœŸå®Œå…¨ç”±å¯¹å®ƒä»¬çš„ä½¿ç”¨éœ€è¦æ¥å†³å®š å­ä¾‹ç¨‹çš„èµ·å§‹å¤„æ˜¯æƒŸä¸€çš„å…¥å£ç‚¹ , æ¯å½“å­ä¾‹ç¨‹è¢«è°ƒç”¨æ—¶ï¼Œæ‰§è¡Œéƒ½ä»è¢«è°ƒç”¨å­ä¾‹ç¨‹çš„èµ·å§‹å¤„å¼€å§‹ , åç¨‹å¯ä»¥æœ‰å¤šä¸ªå…¥å£ç‚¹ , åç¨‹çš„èµ·å§‹å¤„æ˜¯ç¬¬ä¸€ä¸ªå…¥å£ç‚¹ , æ¯ä¸ª yield è¿”å›å‡ºå£ç‚¹éƒ½æ˜¯å†æ¬¡è¢«è°ƒç”¨æ‰§è¡Œæ—¶çš„å…¥å£ç‚¹ å­ä¾‹ç¨‹åªåœ¨ç»“æŸæ—¶ä¸€æ¬¡æ€§çš„è¿”å›å…¨éƒ¨ç»“æœå€¼ , åç¨‹å¯ä»¥åœ¨ yield æ—¶ä¸è°ƒç”¨å…¶ä»–åç¨‹ , è€Œæ˜¯æ¯æ¬¡è¿”å›ä¸€éƒ¨åˆ†çš„ç»“æœå€¼ , è¿™ç§åç¨‹å¸¸ç§°ä¸ºç”Ÿæˆå™¨æˆ–è¿­ä»£å™¨ æˆ‘ä»¬å†å›åˆ°åç¨‹ , åœ¨æœ¬ç¯‡æ–‡ç« å¼€å¤´å°±å·²ç»è¯´è¿‡ , åç¨‹å®é™…ä¸Šæ—©åœ¨çº¿ç¨‹ä¹‹å‰å°±å·²ç»å‡ºç°äº† , ä½†æ˜¯ä¸ºä»€ä¹ˆåç¨‹å´æ²¡æœ‰è¢«æ›´å¹¿æ³›çš„ä½¿ç”¨ , è€Œæ˜¯çº¿ç¨‹å æ®ä¸»å¯¼åœ°ä½å‘¢ ? çº¿ç¨‹ä¸åç¨‹ çº¿ç¨‹ä¸åç¨‹åœ¨æŸäº›æƒ…å†µä¸‹å…¶å®æ˜¯æ²¡æœ‰å¯æ¯”æ€§çš„ , å› ä¸ºåœ¨ç°ä»£ , çº¿ç¨‹æ˜¯ CPU è°ƒåº¦çš„åŸºæœ¬å•ä½ , è€Œåç¨‹æ ¹æœ¬ä¸ä¼šå‚ä¸ CPU è°ƒåº¦ ä»è°ƒåº¦æ–¹å¼æ¥è®² , çº¿ç¨‹çš„è°ƒåº¦æ˜¯ç”±æ“ä½œç³»ç»Ÿæ§åˆ¶çš„ , ä¸”æ˜¯æŠ¢å å¼çš„ ; è€Œåç¨‹çš„è°ƒåº¦æ–¹å¼æ˜¯ç”±ç”¨æˆ·è‡ªå·±æ§åˆ¶çš„ , è¿™ç§è°ƒåº¦éœ€è¦æˆ‘ä»¬çš„ç¨‹åºå»æ§åˆ¶ , ä¸”ä¹Ÿæ— æ³•åƒçº¿ç¨‹ä¸€æ ·å¼ºåˆ¶ä¸­æ–­ , éœ€è¦ç¨‹åºè‡ªå·±ä¸»åŠ¨è®©å‡ºæ‰§è¡Œæƒ , æ‰€ä»¥åç¨‹é€šå¸¸æ˜¯åä½œå¼æˆ–è€…è¯´éæŠ¢å å¼çš„ ä»å¼€é”€æˆæœ¬æ¥è®² , çº¿ç¨‹çš„ä¸Šä¸‹æ–‡åˆ‡æ¢è‡ªç„¶è¦æ¯”åç¨‹çš„ä¸Šä¸‹æ–‡åˆ‡æ¢çš„å¼€é”€è¦å¤§ , ä¸”çº¿ç¨‹å±äºç³»ç»Ÿå¯¹è±¡ , å¯¹ç³»ç»Ÿèµ„æºæ¶ˆè€—ä¹Ÿæ¯”åç¨‹è¦å¤§ , è¿™ä¹Ÿæ˜¯ä¸ºä»€ä¹ˆæœ‰çš„äººæŠŠåç¨‹å«åš \"å¾®çº¿ç¨‹\" , ä½†æ˜¯è¦æ³¨æ„ , è¿™å¹¶ä¸æ„å‘³ç€åç¨‹èƒ½å’Œçº¿ç¨‹åª²ç¾ ä»åˆ©ç”¨æ ¸å¿ƒæ¥è®² , çº¿ç¨‹æ˜¯å¯ä»¥åˆ©ç”¨å¤šæ ¸çš„ , è™½ç„¶åœ¨ Python ä¸­ç”±äº GIL é”æ— æ³•åˆ©ç”¨å¤šæ ¸ä¼˜åŠ¿ , ä½†æ˜¯å®é™…ä¸Šå¾ˆå¤šè¯­è¨€ä¸­çº¿ç¨‹æ˜¯å¯ä»¥åˆ©ç”¨å¤šæ ¸çš„ , è€Œåç¨‹åªèƒ½è·‘åœ¨çº¿ç¨‹ä¸Š , ä¸ç®¡æœ‰æ²¡æœ‰ GIL éƒ½æ— æ³•åˆ©ç”¨å¤šæ ¸ ä» IO æ¥è®² , å½“ç¨‹åºä¸­é‡åˆ° IO æ—¶ , çº¿ç¨‹ä¼šè¢«é˜»å¡ , æ‰€ä»¥åç¨‹è‡ªç„¶ä¹Ÿä¼šè¢«é˜»å¡ , ä½†æ˜¯åœ¨å¤šçº¿ç¨‹çš„æƒ…å†µä¸‹æ¯ä¸ªçº¿ç¨‹ä¹‹é—´çš„é˜»å¡äº’ä¸å½±å“ , è€Œ CPU æ—¶é—´ç‰‡æ˜¯ç”±ç³»ç»Ÿåˆ†é…çš„ , å¦‚æœçº¿ç¨‹å¤„äºç­‰å¾…çŠ¶æ€ , ç³»ç»Ÿè‡ªç„¶ä¼šå°†æ—¶é—´ç‰‡åˆ†é…ç»™å…¶ä»–çº¿ç¨‹ç»§ç»­æ‰§è¡Œ , è¿™ä¹Ÿæ˜¯æˆ‘ä»¬å¹¶å‘æ¨¡å‹ä¸­ä½¿ç”¨æœ€å¤šçš„å¤šçº¿ç¨‹æ¨¡å‹ , æ­¤æ—¶åç¨‹é’ˆå¯¹ IO å°±å·²ç»æ‰è¥Ÿè§è‚˜äº† ç»¼ä¸Š , ä¸ç®¡æ˜¯åœ¨ CPU å¯†é›†å‹çš„ä¸šåŠ¡ä¸‹ , è¿˜æ˜¯åœ¨ IO å¯†é›†å‹çš„ä¸šåŠ¡ä¸‹ , åç¨‹éƒ½ä¸å¦‚çº¿ç¨‹ ; CPU å¯†é›†å‹åœºæ™¯ä¸‹ , æˆ‘ä»¬è¦æé«˜ CPU çš„åˆ©ç”¨ç‡ , æœ‰å‡ ä¸ªæ ¸å¿ƒé‚£å°±ç”¨å‡ ä¸ªæ ¸å¿ƒ , å¦‚æœä¸€ä¸ªæ ¸å¿ƒé…å¤‡ä¸€ä¸ªçº¿ç¨‹ , é‚£å°±æ²¡æœ‰çº¿ç¨‹ä¹‹é—´çš„åˆ‡æ¢äº† , å¼€é”€è‡ªç„¶ä¸ç®—æ˜¯ä»€ä¹ˆé—®é¢˜ ; IO å¯†é›†å‹åœºæ™¯ä¸‹ , åç¨‹æ•´ä¸ªé˜»å¡ , æ ¹æœ¬æ— æ³•ä½¿ç”¨ è¿™æ ·ä¸€æ¯”è¾ƒå¥½åƒåç¨‹æ¯«æ— ç”¨å¤„ , ä½†æ˜¯ä¸è¦å¿˜è®°äº† , é‡åˆ° IO å½“å‰çº¿ç¨‹ä¹Ÿæ²¡æ³•ç»§ç»­æ‰§è¡Œ , å¤šçº¿ç¨‹åªä¸è¿‡æ˜¯åˆ‡æ¢åˆ°äº†å…¶ä»–å°±ç»ªçš„çº¿ç¨‹ç½¢äº† , åœ¨ Python 2 ä¸­é»˜è®¤çº¿ç¨‹æ¯æ‰§è¡Œ100ä¸ªå­—èŠ‚ç å°±ä¼šåˆ‡æ¢(å¯é€šè¿‡ sys.getcheckinterval() è·å–) , è€Œåœ¨ Python 3 ä¸­åˆ™æ”¹æˆäº†å›ºå®šæ—¶é—´åˆ‡æ¢(å¯é€šè¿‡ sys.getswitchinterval è·å–) , è€Œè¿™ç§åƒµç¡¬çš„è°ƒåº¦æ–¹å¼ä¼šå¯¼è‡´å¾ˆå¤šæ— æ•ˆçš„åˆ‡æ¢ , å½“çº¿ç¨‹æ•°è¶Šå¤§ , å¸¦æ¥çš„æ€§èƒ½æŸè€—å°±è¶Šå¤§ æˆ‘ä»¬ä¹‹æ‰€ä»¥åˆ‡æ¢å®é™…ä¸Šæ›´å¤šçš„åŸå› æ˜¯ç”±äºæœ‰ IO é˜»å¡(å½“ç„¶ä¹Ÿæœ‰å…¬å¹³æ€§) , æ‰€ä»¥ä¸ºäº†é™ä½è¿™ç§æ€§èƒ½æŸè€— , æˆ‘ä»¬å¯ä»¥æ”¹å˜ IO çš„å¤„ç†æ–¹å¼ , è®©çº¿ç¨‹å¯ä»¥è·³è¿‡ IO ä¸”ä¸ä¸¢å¤± CPU çš„åˆ©ç”¨ç‡ , åœ¨å‰é¢çš„æ–‡ç« ä¸­å·²ç»ä»‹ç»äº†6ç§IOæ¨¡å‹ , è¿™é‡Œè¦è¯´çš„æ­£æ˜¯IOå¤šè·¯å¤ç”¨æ¨¡å‹ , è€Œè¿™ä¸ªæ¨¡å‹å¸¦ç»™æˆ‘ä»¬çš„æŒ‘æˆ˜å°±æ˜¯ , æˆ‘ä»¬éœ€è¦é€šè¿‡å›è°ƒçš„æ–¹å¼æ¥å®ç°æˆ‘ä»¬çš„ä¸šåŠ¡ , è€Œå›è°ƒåµŒå¥—å°±å½¢æˆäº†å›è°ƒé“¾ä¹Ÿå°±æ˜¯å›è°ƒåœ°ç‹± å›è°ƒä¸åç¨‹ æˆ‘ä»¬å…ˆæ¥å›é¡¾ä¸€ä¸‹ã€ŠAIOå®ç°ã€‹ä¸­çš„ä¾‹å­ : å›è°ƒç‰ˆæœ¬ import socket from selectors import DefaultSelector, EVENT_READ, EVENT_WRITE def server(host, port): selector = DefaultSelector() sock = socket.socket() sock.bind((host, port)) sock.listen(5) sock.setblocking(False) def accept(sock, mask): print('Accept ...') conn, addr = sock.accept() def connect(conn, mask): print('Connect ...') data = conn.recv(1024).decode('utf-8') def write(conn, mask): print('Write ...') def success(conn, mask): print('Success ...') selector.unregister(conn) conn.close() selector.modify(conn, EVENT_READ, success) selector.modify(conn, EVENT_WRITE, write) conn.send(b'ok') selector.register(conn, EVENT_READ, connect) selector.register(sock, EVENT_READ, accept) print('å¯åŠ¨æœåŠ¡ç«¯...') while True: ready = selector.select() for event, mask in ready: callable = event.data callable(event.fileobj, mask) if __name__ == '__main__': server('localhost', 8888) åœ¨å›è°ƒç‰ˆæœ¬ä¸­ , æˆ‘ä»¬æŠ½å‡ºå›è°ƒéƒ¨åˆ† : def accept(sock, mask): print('Accept ...') def connect(conn, mask): print('Connect ...') def write(conn, mask): print('Write ...') def success(conn, mask): print('Success ...') selector.modify(conn, EVENT_READ, success) selector.modify(conn, EVENT_WRITE, write) selector.register(conn, EVENT_READ, connect) selector.register(sock, EVENT_READ, accept) # åŒæ­¥è°ƒç”¨(ç”±ä¸Šè€Œä¸‹): accept -> connect -> write -> success # å¼‚æ­¥è°ƒç”¨(ç”±å†…è€Œå¤–): accept(connect(write(success()))) å›è°ƒå°±æ„å‘³ç€ç¨‹åºæœ‰ä¾èµ–å…³ç³» , è€Œä¾èµ–å…³ç³»å°±ä¼šå½¢æˆå›è°ƒé“¾ , å›è°ƒé“¾ä¸€æ—¦è¿‡é•¿å°±ä¼šå°±æˆäº†å›è°ƒåœ°ç‹± , å› ä¸ºæˆ‘ä»¬ä¸çŸ¥é“äº‹ä»¶ä»€ä¹ˆæ—¶å€™å¯ä»¥å®Œæˆ , æ‰€ä»¥æˆ‘ä»¬å¿…é¡»é¢„å…ˆå®šä¹‰å¥½äº‹ä»¶å®Œæˆåå°†è¦å›è°ƒçš„å‡½æ•° , å¦‚æœæˆ‘ä»¬èƒ½å¤Ÿåœ¨äº‹ä»¶å¼€å§‹ç›‘å¬æ—¶ä¸­æ–­ç¨‹åº , åœ¨äº‹ä»¶å®Œæˆå›è°ƒæ—¶æ¢å¤ç¨‹åº , æ˜¯ä¸æ˜¯å°±ä¸éœ€è¦é¢„å…ˆå®šä¹‰å›è°ƒå‡½æ•°äº†å‘¢ ? ä¸ç®¡å›è°ƒé“¾æœ‰å¤šé•¿ , æˆ‘ä»¬åªéœ€è¦è®©ç¨‹åºä¸æ–­çš„è‡ªæˆ‘ä¸­æ–­ , å†æ¢å¤ , ç›´åˆ°ç¨‹åºæ‰§è¡Œå®Œæ¯• , ä¸€åˆ‡ä¼¼ä¹å°±å˜å¾—ç®€å•èµ·æ¥äº† , é‚£æˆ‘ä»¬è¦æ€ä¹ˆå»å®ç°å‘¢ ? ç­”æ¡ˆæ˜¯ : åç¨‹ é‚£ä¹ˆè®©æˆ‘ä»¬æ¥æ”¹é€ ä¸€ä¸‹ä¸Šé¢è¿™æ®µä»£ç  : import socket from inspect import isfunction from selectors import DefaultSelector, EVENT_READ, EVENT_WRITE def server(host, port): selector = DefaultSelector() sock = socket.socket() sock.bind((host, port)) sock.listen(5) sock.setblocking(False) def handler(): gen = accept() gen.send(None) gen.send(gen) def accept(): gen = yield print('Accept ...') conn, addr = sock.accept() selector.register(conn, EVENT_READ, gen) yield print('Connect ...') data = conn.recv(1024).decode('utf-8') selector.modify(conn, EVENT_WRITE, gen) conn.send(b'ok') yield print('Write ...') selector.modify(conn, EVENT_READ, gen) yield print('Success ...') selector.unregister(conn) conn.close() yield selector.register(sock, EVENT_READ, handler) print('å¯åŠ¨æœåŠ¡ç«¯...') while True: ready = selector.select() for event, mask in ready: if isfunction(event.data): event.data() else: try: event.data.send(event.fileobj) except StopIteration as e: continue if __name__ == '__main__': server('localhost', 8888) æ¯ä¸€æ¬¡ yield éƒ½å°†æ‰§è¡Œæƒé™è®©å‡º , ç­‰å¾…äº‹ä»¶å›è°ƒå‘ç”Ÿ , è¿™å°±æ˜¯åç¨‹çš„é­…åŠ› , å›è°ƒçš„å¼‚æ­¥ä»£ç å˜æˆäº†ä¸€ç§åŒæ­¥çš„æ–¹å¼ ä¸è¿‡ , å¦‚æœæˆ‘ä»¬è¿™æ ·å»ç¼–å†™å¼‚æ­¥ç¨‹åº , é‚£ä¹Ÿå¾—è´¹ä¸å°‘åŠ² , è™½ç„¶ä»£ç çœ‹ç€åŒæ­¥äº† , ä½†æ˜¯å›è°ƒæ³¨å†Œå´å¹¶å‹å¥½ , æœ‰æ²¡æœ‰æ³•å­å¯ä»¥è®©æˆ‘ä»¬ä¸å…³å¿ƒå›è°ƒæ³¨å†Œ ? å…ˆæ€è€ƒä¸€ä¸‹ , åœ¨ä¸‹ä¸€ç¯‡ã€ŠAIOåç¨‹å®ç°ã€‹ä¸­ , æˆ‘ä»¬å†æ¥ä¼˜åŒ– åç¨‹ç»™æˆ‘ä»¬å¸¦æ¥çš„æœ€å¤§å¥½å¤„å®é™…ä¸Šå¹¶ä¸æ˜¯æ€§èƒ½ , è€Œæ˜¯æˆ‘ä»¬å¯ä»¥é€šè¿‡åç¨‹æ¥å°†å¼‚æ­¥ä»£ç ç”¨åŒæ­¥çš„æ–¹å¼ç¼–å†™ ç°åœ¨æˆ‘ä»¬å…¶å®è¿˜æœ‰ä¸€ä¸ªé—®é¢˜é‚£å°±æ˜¯åç¨‹å¦‚ä½•è°ƒåº¦ , è¿™å°±æ˜¯æˆ‘ä»¬æ¥ä¸‹æ¥è¦è¯´çš„äº‹ä»¶å¾ªç¯ äº‹ä»¶å¾ªç¯ äº‹ä»¶å¾ªç¯ æ˜¯ä¸€ç§ç¨‹åºç»“æ„æˆ–è®¾è®¡æ¨¡å¼ , ç”¨äºåœ¨ç¨‹åºä¸­ç­‰å¾…å’Œåˆ†å‘äº‹ä»¶æˆ–è€…æ¶ˆæ¯ , ç®€å•æ¥è¯´å°±æ˜¯å½“æŸä»¶äº‹æƒ…å‘ç”Ÿæ—¶ , æ¥ä¸‹æ¥è¯¥åšä»€ä¹ˆ , é€šå¸¸å®ƒæ˜¯ä¸€ä¸ªæ­»å¾ªç¯ , å› ä¸ºå®ƒéœ€è¦ä¸æ–­çš„æ”¶é›†äº‹ä»¶å¹¶å¤„ç†äº‹ä»¶ åœ¨ä¸Šé¢çš„ä»£ç ä¸­å…¶å®æˆ‘ä»¬å·²ç»å®ç°äº†ä¸€ä¸ªæœ€ç®€å•çš„äº‹ä»¶å¾ªç¯ : # æ°¸ä¸åœæ­‡çš„æ”¶é›†äº‹ä»¶å¹¶å¤„ç†äº‹ä»¶ while True: # æ”¶é›†å°±ç»ªçš„äº‹ä»¶åˆ—è¡¨ ready = selector.select() # å¾ªç¯å¤„ç†äº‹ä»¶ for event, mask in ready: if isfunction(event.data): event.data() else: try: event.data.send(event.fileobj) except StopIteration as e: continue äº‹ä»¶å¾ªç¯ä¸Šå°±æ˜¯ä¸€ä¸ªè°ƒåº¦å™¨ , æ˜¯æˆ‘ä»¬ç”¨æˆ·ç¨‹åºä¹‹é—´çš„è°ƒåº¦å™¨ , å°±æ˜¯æ“ä½œç³»ç»Ÿè°ƒåº¦çº¿ç¨‹ä¸€æ · , äº‹ä»¶å¾ªç¯å¯ä»¥ç”¨æ¥è°ƒåº¦æˆ‘ä»¬çš„åç¨‹ , æ‰€ä»¥é€šå¸¸ä½ ä¼šå‘ç°åç¨‹æ€»æ˜¯å’Œäº‹ä»¶å¾ªç¯åŒæ—¶å‡ºç° , æ‰€ä»¥æˆ‘ä»¬å¯¹äº‹ä»¶å¾ªç¯çš„è¦æ±‚ä¸€èˆ¬éƒ½æ¯”è¾ƒé«˜ , å› ä¸ºåç¨‹è°ƒåº¦çš„æ€§èƒ½ç›´æ¥ç”±äº‹ä»¶å¾ªç¯çš„è°ƒåº¦æ–¹æ¡ˆå†³å®š åœ¨æ—©æœŸçš„ Python ä¸­ , ç”± gevent æä¾›äº†äº‹ä»¶å¾ªç¯èƒ½åŠ› , è€Œ Python 3.4 æ—¶å¼•å…¥ asyncio æ ‡å‡†åº“æ¥æä¾›äº‹ä»¶å¾ªç¯èƒ½åŠ› å…³äºäº‹ä»¶å¾ªç¯çš„å…·ä½“å®ç° , è¯·é˜…è¯»åç»­æ–‡ç«  async&await æœ€åæˆ‘ä»¬æ¥è¯´è¯´ async å’Œ await åœ¨ Python 3.4 ä¸­ # This also works in Python 3.5. import asyncio.coroutine @asyncio.coroutine def py34_coro(): yield from stuff() å¯¹åº”çš„å­—èŠ‚ç  >>> dis.dis(py34_coro) 2 0 LOAD_GLOBAL 0 (stuff) 3 CALL_FUNCTION 0 (0 positional, 0 keyword pair) 6 GET_YIELD_FROM_ITER 7 LOAD_CONST 0 (None) 10 YIELD_FROM 11 POP_TOP 12 LOAD_CONST 0 (None) 15 RETURN_VALUE åœ¨ Python 3.5 ä¸­ async def py35_coro(): await stuff() å¯¹åº”çš„å­—èŠ‚ç  >>> dis.dis(py35_coro) 1 0 LOAD_GLOBAL 0 (stuff) 3 CALL_FUNCTION 0 (0 positional, 0 keyword pair) 6 GET_AWAITABLE 7 LOAD_CONST 0 (None) 10 YIELD_FROM 11 POP_TOP 12 LOAD_CONST 0 (None) 15 RETURN_VALUE å®ƒä»¬ä¹‹é—´çš„å·®å¼‚ä»…ä»…æ˜¯ GET_YIELD_FROM_ITER å’Œ GET_AWAITABLE çš„å·®å¼‚ , è€Œè¿™ä¸¤ä¸ªå‡½æ•°å®é™…ä¸Šéƒ½æ˜¯ç”¨æ¥æ ‡è®°åç¨‹çš„ , æ‰€ä»¥å…¶å® yield from å’Œ async/await å¹¶æ— ä¸¤æ · GET_YIELD_FROM_ITER å¯ä»¥æ¥æ”¶ç”Ÿæˆå™¨æˆ–è€…åç¨‹ , è€Œ GET_AWAITABLE åªæ¥å—åç¨‹ æ‰€ä»¥ async/await å¹¶æ²¡æœ‰åšä»€ä¹ˆç‰¹æ®Šçš„æå‡ , è¿™ä¸¤ä¸ªå…³é”®å­—ä¹Ÿä¸»è¦æ˜¯ä¸ºäº†å°†åç¨‹è§„èŒƒåŒ– , æ˜ç¡®äº†åç¨‹çš„æ„ä¹‰ , è€Œä¸æ˜¯å°†ç”Ÿæˆå™¨å’Œåç¨‹æ··åœ¨ä¸€èµ· è¿™äº›ä¹Ÿéƒ½æ˜¯æœ‰è¿¹å¯å¾ªçš„ : 3.4ï¼šasyncio åœ¨ Python æ ‡å‡†åº“ä¸­å¼•å…¥ , ä½†æ˜¯åªæ˜¯ä¸´æ—¶çš„ 3.5ï¼šasync/await æˆä¸º Python è¯­æ³•çš„ä¸€éƒ¨åˆ† , ç”¨äºè¡¨ç¤ºå’Œç­‰å¾…åç¨‹ , ä½†å®ƒä»¬è¿˜ä¸æ˜¯ä¿ç•™å…³é”®å­— 3.6ï¼šå¼•å…¥äº†å¼‚æ­¥ç”Ÿæˆå™¨å’Œå¼‚æ­¥å¾ªç¯ , asyncio ä¸å†åªæ˜¯ä¸´æ—¶çš„ , è€Œæ˜¯ç¨³å®šçš„ 3.7ï¼šasync/await æˆä¸ºä¿ç•™å…³é”®å­— , å®ƒä»¬æ—¨åœ¨æ›¿æ¢ asyncio.coroutine() è£…é¥°å™¨ åˆ°è¿™é‡Œ , åç¨‹çš„å‰ä¸–ä»Šç”Ÿæˆ‘ä»¬å·²ç»ç†æ¸…äº† , ä¸è¿‡è¿˜æœ‰ä¸€ç‚¹ , gevent æ˜¯æœ‰æ ˆåç¨‹çš„ä»£è¡¨ , è€Œ asyncio æ˜¯æ— æ ˆåç¨‹çš„ä»£è¡¨ , å…³äºæœ‰æ ˆåç¨‹å’Œæ— æ ˆåç¨‹çš„å…·ä½“ç»†èŠ‚ , è¯·å…³æ³¨æˆ‘åç»­çš„æ–‡ç«  æœ€åæˆ‘ä»¬æ¥ç®€å•æ€»ç»“ä¸€ä¸‹ æ€»ç»“ åç¨‹éš¾çš„åŸå› å…¶å®ä¸æ˜¯å®ƒæœ¬èº« , è€Œæ˜¯æˆ‘ä»¬éœ€è¦ä»å†å²å‡ºå‘ , ç†æ¸…å®ƒçš„å‰ä¸–ä»Šç”Ÿ ç½‘ç»œä¸Šå…³äºåç¨‹ç›¸å…³çš„æ–‡ç« æ›´å¤šçš„æ˜¯ç”¨æ³• , è€Œä»ç”¨æ³•å‡ºå‘ , å¾ˆå¤šä¸œè¥¿éƒ½å·²ç»è¢«éšè—äº† , å¯¼è‡´ä¸­é—´å‡ºç°äº†æ–­å±‚ åœ¨æœ¬ç¯‡ä¸­ , æˆ‘ä»¬å¹¶æ²¡æœ‰ä»‹ç»åç¨‹çš„ç”¨æ³• , è€Œæ˜¯ä»æºå¤´å‡ºå‘ : åç¨‹å®é™…ä¸Šæ˜¯ä¸ºäº†è§£å†³å•æ ¸å¤šä»»åŠ¡å¹¶å‘é—®é¢˜ åç¨‹å¯ä»¥é™ä½å¼‚æ­¥å›è°ƒçš„å¤æ‚æ€§ , å°†å¼‚æ­¥ä»£ç åŒæ­¥åŒ–(è¿™é‡Œåªæ˜¯è¯´ç¼–å†™é£æ ¼) åç¨‹éœ€è¦æœ‰äº‹ä»¶å¾ªç¯æ¥è°ƒåº¦ async/awiat å¯ä»¥çœ‹åšæ˜¯ yield from çš„è¯­æ³•ç³– , å°†ç”Ÿæˆå™¨ä¸åç¨‹è¿›è¡Œéš”ç¦» å‚è€ƒèµ„æ–™ ã€Šæµç•…çš„Pythonã€‹ python-async-features how-the-heck-docs-async-await-work-in-python-3.5 i-dont-understand-asyncio æ·±å…¥ç†è§£ Python å¼‚æ­¥ç¼–ç¨‹ï¼ˆä¸Šï¼‰ "},"09-AIOåç¨‹å®ç°.html":{"url":"09-AIOåç¨‹å®ç°.html","title":"AIOåç¨‹å®ç°","keywords":"","body":"Attack on Tornado - AIOåç¨‹å®ç° ğŸŒª å‰è¨€ è™½ç„¶åœ¨ä¸Šä¸€ç¯‡ä¸­æˆ‘ä»¬é€šè¿‡åç¨‹è§£å†³äº†å›è°ƒåœ°ç‹±é—®é¢˜ , ä½†æ˜¯å›è°ƒæ³¨å†Œæ–¹å¼è¿˜æ˜¯ä¸å¤Ÿç®€å• , å› ä¸ºä½œä¸ºç”¨æˆ·æ¥è®² , æˆ‘ä»¬ä¸åº”è¯¥å»å…³å¿ƒæ³¨å†Œå›è°ƒäº‹ä»¶ æˆ‘ä»¬å¸Œæœ›æœ‰ä¸€ä¸ªå›è°ƒæ§åˆ¶å™¨å¯ä»¥è‡ªåŠ¨å¸®æˆ‘ä»¬æ³¨å†Œå›è°ƒ , æˆ‘ä»¬åªå…³å¿ƒä¸šåŠ¡é€»è¾‘ , è€Œå¯¹æˆ‘ä»¬è€Œè¨€ä¸šåŠ¡é€»è¾‘å¿…ç„¶å¤„äºåç¨‹ä¸­ , é‚£ä¹ˆè¿™ä¸ªæ§åˆ¶å™¨è‚¯å®šæ˜¯ä»äº‹ä»¶å¾ªç¯å…¥æ‰‹äº† AIOåç¨‹è¿›é˜¶ æˆ‘ä»¬å¯ä»¥å®šä¹‰ä¸€ä¸ªåŸºç±» Event , å…¶ä¸­å®šä¹‰ä¸¤ä¸ª API åˆ†åˆ«æ§åˆ¶ : æ³¨å†Œå›è°ƒäº‹ä»¶ä¸å¤„ç†å›è°ƒäº‹ä»¶ , éšåæ¯ç§äº‹ä»¶éƒ½ç»§æ‰¿åŸºç±» Event , åœ¨ä½¿ç”¨æ—¶ , ç›´æ¥å°†äº‹ä»¶æ¨å…¥äº‹ä»¶å¾ªç¯ , ç»Ÿä¸€ç”±äº‹ä»¶å¾ªç¯è¿›è¡Œè°ƒåº¦ class Event: def _yield(self, loop, task): \"\"\"ç”¨äºæ³¨å†Œå›è°ƒ\"\"\" raise NotImplementedError def _resume(self, loop, task): \"\"\"å¤„ç†å›è°ƒ, å¹¶å°†å›è°ƒå‡½æ•°æ”¾å…¥å‡†å¤‡é˜Ÿåˆ—\"\"\" raise NotImplementedError æˆ‘ä»¬å®šä¹‰ä¸¤ç§äº‹ä»¶ , Accept å’Œ Read äº‹ä»¶ , ç”¨äºæ¥æ”¶è¯·æ±‚å¹¶æ¥æ”¶è¯·æ±‚ä¸­çš„æ•°æ® class ReadEvent(Event): def __init__(self, sock): self.sock = sock def _yield(self, loop, task): loop._read_wait(self.sock.fileno(), self, task) def _resume(self, loop, task): data = self.sock.recv(1024) loop._ready.append((task, data)) class AcceptEvent(Event): def __init__(self, sock): self.sock = sock def _yield(self, loop, task): loop._read_wait(self.sock.fileno(), self, task) def _resume(self, loop, task): r = self.sock.accept() loop._ready.append((task, r)) äº‹ä»¶å¾ªç¯é™¤äº†ç»´æŠ¤äº‹ä»¶é˜Ÿåˆ—ä¹‹å¤– , è¿˜ç»´æŠ¤ä¸€ä¸ªå°±ç»ªä»»åŠ¡é˜Ÿåˆ—ç”¨äºæ‰§è¡Œè·Ÿäº‹ä»¶æ— å…³çš„å…¶ä»–ä¸šåŠ¡é€»è¾‘ import select from collections import deque class EventLoop: def __init__(self): self._num_tasks = 0 # Total num of tasks self._ready = deque() # Tasks ready to run self._read_waiting = {} # Tasks waiting to read self._write_waiting = {} # Tasks waiting to write def _io_poll(self): \"\"\" Poll for I/O events and restart waiting tasks \"\"\" if -1 in self._read_waiting: self._read_waiting.pop(-1) # è¿™é‡Œåªæ˜¯ä¸ºäº†æ–¹ä¾¿è°ƒè¯•æ‰€ä»¥ä½¿ç”¨çš„select r_set, w_set, e_set = select.select(self._read_waiting, self._write_waiting, []) for r in r_set: event, task = self._read_waiting.pop(r) event._resume(self, task) def call_soon(self, task): self._ready.append((task, None)) self._num_tasks += 1 def _read_wait(self, fileno, event, task): \"\"\" Add a event to the reading set \"\"\" self._read_waiting[fileno] = (event, task) def run_forever(self): ''' Run the task eventloop until there are no tasks ''' while self._num_tasks: if not self._ready: self._io_poll() task, data = self._ready.popleft() try: # Run the coroutine to the next yield r = task.send(data) if isinstance(r, Event): r._yield(self, task) else: raise RuntimeError('unrecognized yield event') except StopIteration: self._num_tasks -= 1 å› ä¸ºæˆ‘ä»¬éœ€è¦å¾ªç¯ä¸æ–­çš„æ¥æ”¶è¯·æ±‚ , æ‰€ä»¥æˆ‘ä»¬è¿˜éœ€è¦ç¼–å†™ä¸€ä¸ªæ¥æ”¶å‡½æ•°ä»¥åŠå¤„ç†å‡½æ•° if __name__ == '__main__': import socket def handle_events(conn): while True: line = yield ReadEvent(conn) print(line.decode('utf-8')) conn.close() def server_loop(loop, host, port): sock = socket.socket() sock.bind((host, port)) sock.listen(5) sock.setblocking(False) print('å¯åŠ¨æœåŠ¡ç«¯...') while True: conn, a = yield AcceptEvent(sock) print('Got connection from ', a) loop.call_soon(handle_events(conn)) loop = EventLoop() loop.call_soon(server_loop(loop, 'localhost', 8888)) loop.run_forever() å½“ç„¶è¿˜æœ‰ client import time import json import socket import datetime def client(host, port): sock = socket.socket() sock.connect((host, port)) data = { 'send_user': 'Lyon', 'send_time': datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S'), 'send_msg': 'BIO test...' } sock.send(json.dumps(data).encode('utf-8')) time.sleep(5) sock.send(json.dumps(data).encode('utf-8')) sock.close() print('å®¢æˆ·ç«¯å‘é€æ•°æ®æˆåŠŸ...') if __name__ == '__main__': client('localhost', 8888) å°±è¿™æ ·æˆ‘ä»¬çš„ä¼˜åŒ–å°±å®Œæˆäº† , æˆ‘ä»¬å¯ä»¥æŠŠå…¶ä»–è·Ÿäº‹ä»¶æ— å…³çš„ä»»åŠ¡é€šè¿‡ call_soon æ–¹æ³•æ·»åŠ åˆ° _ready å°±ç»ªé˜Ÿåˆ—ä¸­ , å°±åƒ server_loop ç°åœ¨å·²ç»å¾ˆæ¥è¿‘ asyncio äº† , åªä¸è¿‡æˆ‘ä»¬è¦è¾¾åˆ°åƒ asyncio æ”¯æŒçš„é‚£æ · , è¿˜éœ€è¦åšä¸å°‘å·¥ä½œ , æˆ‘ä»¬çš„ç›®çš„æ˜¯å»ç†è§£è¿™ç§ç¼–ç¨‹æ–¹å¼ , æ‰€ä»¥ä¸‹ä¸€ç¯‡æˆ‘ä»¬ç›´æ¥ä»‹ç» asyncio å‚è€ƒèµ„æ–™ ã€ŠPython Cookbookã€‹ "},"09-asyncio.html":{"url":"09-asyncio.html","title":"asyncio","keywords":"","body":"Attack on Tornado - asyncio ğŸŒª "},"10-IOLoop.html":{"url":"10-IOLoop.html","title":"IOLoop","keywords":"","body":"Attack on Tornado - IOLoop ğŸŒª ä»‹ç» IOLoop æ˜¯å¼‚æ­¥éé˜»å¡æ¨¡å‹çš„å…³é”®æ‰€åœ¨ , æˆ‘ä»¬ä»¥ asyncio ä¸ºä¾‹æ¥åˆ†æ Tornado çš„æºç å®ç° å¼€å§‹ æˆ‘ä»¬ä¼šå›´ç»•å®˜æ–¹çš„ä¸€ä¸ªä¾‹å­æ¥è¿›è¡Œæºç åˆ†æ , ç¤ºä¾‹å¦‚ä¸‹ : import tornado.ioloop import tornado.web class MainHandler(tornado.web.RequestHandler): def get(self): self.write(\"Hello, world\") if __name__ == \"__main__\": application = tornado.web.Application([ (r\"/\", MainHandler), ]) application.listen(8888) tornado.ioloop.IOLoop.current().start() ä¸ºäº†èŠ‚çœç¯‡å¹… , ä¼šçœç•¥éƒ¨åˆ†å®˜æ–¹æ³¨é‡Š , å› ä¸ºæœ¬èŠ‚çš„é‡ç‚¹ä¸åœ¨ tornado.web.Application è¿™ä¸ªåº”ç”¨å¯¹è±¡ä¸Š , æ‰€ä»¥æˆ‘ä»¬åœ¨è¿™èŠ‚ä¸­ä¸ä¼šè¿‡å¤šçš„å»åˆ†æ Application Configurable åœ¨å¼€å§‹ä¹‹å‰ , æˆ‘ä»¬éœ€è¦å…ˆçœ‹ä¸€ä¸‹ Configurable çš„æºç  , å› ä¸ºå®ƒæ”¹å˜äº†æˆ‘ä»¬æ­£å¸¸å¯¹è±¡åˆå§‹åŒ–æµç¨‹ , ä¸”åœ¨ Tornado ä¸­åŸºæœ¬å¤§å¤šæ•°ç±»éƒ½ç»§æ‰¿äº† Configurable # type: tornado.util.Configurable class Configurable(object): __impl_class = None # type: Optional[Type[Configurable]] __impl_kwargs = None # type: Dict[str, Any] def __new__(cls, *args: Any, **kwargs: Any) -> Any: base = cls.configurable_base() init_kwargs = {} # type: Dict[str, Any] if cls is base: impl = cls.configured_class() if base.__impl_kwargs: init_kwargs.update(base.__impl_kwargs) else: impl = cls init_kwargs.update(kwargs) if impl.configurable_base() is not base: # The impl class is itself configurable, so recurse. return impl(*args, **init_kwargs) # è°ƒç”¨objectçš„__new__æ–¹æ³• instance = super(Configurable, cls).__new__(impl) # è°ƒç”¨å®ä¾‹çš„ initialize æ–¹æ³• # åœ¨Tornadoä¸­, ç»§æ‰¿äº† Configurable çš„ç±»çš„ __init__ åŸºæœ¬éƒ½æ˜¯ pass å¸¦è¿‡ # çœŸæ­£çš„åˆå§‹åŒ–éƒ½æ”¾åœ¨ initialize æ–¹æ³•ä¸­, æ‰€ä»¥å¦‚æœä½ å‘ç°äº† initialize , é‚£ä¹ˆæ²¡é”™, å®ƒå°±æ˜¯çœŸæ­£çš„ `__init__` instance.initialize(*args, **init_kwargs) return instance listen application.listen def listen(self, port: int, address: str = \"\", **kwargs: Any) -> HTTPServer: # type: tornado.httpserver.HTTPServer(TCPServer, Configurable, httputil.HTTPServerConnectionDelegate) # type: tornado.tcpserver.TCPServer server = HTTPServer(self, **kwargs) # type: tornado.tcpserver.TCPServer.listen server.listen(port, address) return server tornado.tcpserver.TCPServer.listen def listen(self, port: int, address: str = \"\") -> None: # type: tornado.netutil.bind_sockets # bind_socketsæ˜¯ç”¨æ¥åˆ›å»ºå¥—æ¥å­—çš„, é»˜è®¤ä¼šæ ¹æ®ç³»ç»Ÿéœ€è¦åˆ›å»ºç›¸åº”çš„å¥—æ¥å­— # ä»¥Macä¸ºä¾‹, ä¼šåˆ›å»ºå‡º AF_INET å’Œ AF_INET6 ä¸¤ä¸ªå¥—æ¥å­— \"\"\" sockets : [ , ] \"\"\" sockets = bind_sockets(port, address=address) # type: tornado.tcpserver.TCPServer.add_sockets self.add_sockets(sockets) tornado.tcpserver.TCPServer.add_sockets def add_sockets(self, sockets: Iterable[socket.socket]) -> None: for sock in sockets: # self._sockets, self._handlers æ˜¯ä¸¤ä¸ªdict # sock.fileno()ä¼šè¿”å›ä¸€ä¸ªæ–‡ä»¶æè¿°ç¬¦, ç„¶åä»¥æ–‡ä»¶æè¿°ç¬¦ä¸ºkey, socketå¯¹è±¡ä¸ºvalueå­˜å‚¨åˆ°serverå¯¹è±¡ä¸­ # sock type: socket.socket() self._sockets[sock.fileno()] = sock # type: tornado.netutil.add_accept_handler # åœ¨add_accept_handlerä¸­ä¼šå®ŒæˆIOLoopçš„åˆ›å»º, ä»¥åŠå¥—æ¥å­—ç»‘å®šåˆ°äº‹ä»¶å¾ªç¯ä¸Š self._handlers[sock.fileno()] = add_accept_handler( sock, self._handle_connection ) # slef._handle_connection çœ‹åå­—æˆ‘ä»¬ä¹Ÿèƒ½çŸ¥é“è¿™æ˜¯å¤„ç†è¿æ¥çš„å›è°ƒå‡½æ•° add_accept_handler tornado.netutil.add_accept_handler def add_accept_handler( sock: socket.socket, callback: Callable[[socket.socket, Any], None] ) -> Callable[[], None]: # type: tornado.platform.asyncio.AsyncIOMainLoop(BaseAsyncIOLoop) # type: tornado.platform.asyncio.BaseAsyncIOLoop(IOLoop) # type: tornado.ioloop.IOLoop # IOLoop.current(instance=True) => tornado.ioloop.IOLoop.current \"\"\" åœ¨è¿™é‡Œæœ‰ä¸€ä¸ªå…³é”®çš„åœ°æ–¹å°±æ˜¯åœ¨ AsyncIOMainLoop(make_current=True)çš„æ—¶å€™ def initialize(self, **kwargs: Any) -> None: # type: ignore è¿™é‡Œä¼šä½¿ç”¨asyncioå»è·å–åˆ°å½“å‰çš„äº‹ä»¶å¾ªç¯, å¹¶ä½œä¸ºå‚æ•°, åˆ°è¾¾BaseAsyncIOLoop.initialize super().initialize(asyncio.get_event_loop(), **kwargs) \"\"\" io_loop = IOLoop.current() # å…¶ä»–éƒ¨åˆ†æš‚æ—¶çœç•¥, æˆ‘ä»¬å…ˆçœ‹çœ‹IOLoopæ˜¯æ€ä¹ˆåˆ›å»ºçš„ tornado.platform.asyncio.AsyncIOMainLoop.initialize def initialize(self, **kwargs: Any) -> None: # type: ignore # è¿™é‡Œå¾ˆå…³é”®, å› ä¸ºå®ƒå…¶å®ä½¿ç”¨äº†asyncioå»è·å–å½“å‰çº¿ç¨‹çš„äº‹ä»¶å¾ªç¯, ç„¶åå°†æ‹¿åˆ°çš„eventloopä½œä¸ºå‚æ•°ä¼ å…¥äº†BaseAsyncIOLoop.initialize super().initialize(asyncio.get_event_loop(), **kwargs) tornado.platform.asyncio.BaseAsyncIOLoop.initialize def initialize(self, asyncio_loop: asyncio.AbstractEventLoop, **kwargs: Any) -> None: # è¿™é‡Œå¯ä»¥çœ‹åˆ°å®˜æ–¹çš„æ ‡æ³¨æ˜¯asyncio.AbstractEventLoop, å®é™…ä¸Šasyncioè¿™é‡Œçš„å®ç°è¦å¤æ‚å¾—å¤š, æˆ‘ä»¬å¯ä»¥æ”¾åœ¨åé¢çš„æ–‡ç« ä¸­ # å¦‚æœä½ çœ‹è¿‡asyncioçš„æºç , é‚£åœ¨è¿™é‡Œåƒä¸‡åˆ«ææ··äº†, å› ä¸ºtornado.ioloop.IOLoopå®é™…ä¸Šæ˜¯è®²asyncioä¸­çš„loopä½œä¸ºä¸€ä¸ªæˆ–è€…è¯´ä¸¤ä¸ªå±æ€§æ¥ä½¿ç”¨çš„, å¹¶ä¸æ˜¯ç»§æ‰¿çš„æ–¹å¼, æ‰€ä»¥ä¸¤è€…å­˜åœ¨ä¸€äº›å·®å¼‚ self.asyncio_loop = asyncio_loop self.selector_loop = asyncio_loop if hasattr(asyncio, \"ProactorEventLoop\") and isinstance( asyncio_loop, asyncio.ProactorEventLoop # type: ignore ): self.selector_loop = AddThreadSelectorEventLoop(asyncio_loop) self.handlers = {} self.readers = set() # type: Set[int] self.writers = set() # type: Set[int] self.closing = False for loop in list(IOLoop._ioloop_for_asyncio): if loop.is_closed(): del IOLoop._ioloop_for_asyncio[loop] # åœ¨è¿™é‡Œå°±ä¼šè®²asyncio_loopå­˜æ”¾åˆ°IOLoopçš„ç±»å˜é‡ä¸­ # è¿™é‡Œè¦æ³¨æ„çš„, åœ¨å…¶ä»–çš„åœ°æ–¹å¯èƒ½ä¼šä½¿ç”¨asyncioçš„get_event_loopæ–¹æ³•æ¥è·å–asyncio_loop # è¿™æ ·å†é€šè¿‡asyncio_loopå°±å¯ä»¥åˆ°ç±»å˜é‡ä¸­æ‹¿åˆ°tornado.platform.asyncio.AsyncIOMainLoop # ä½ å¯ä»¥åœ¨IOLoopçš„currentä¸­çœ‹åˆ°è¿™å—ä»£ç  IOLoop._ioloop_for_asyncio[asyncio_loop] = self self._thread_identity = 0 super().initialize(**kwargs) # assign_thread_identityå°†ä¼šåœ¨IOLoop.start()çš„æ—¶å€™è¢«å›è°ƒ def assign_thread_identity() -> None: self._thread_identity = threading.get_ident() # type: tornado.platform.asyncio.BaseAsyncIOLoop.add_callback # è¿™ä¸ªadd_callbackå…¶å®ä½¿ç”¨çš„å°±æ˜¯asyncioä¸­loopçš„add_callback, å®ƒçš„åšç”¨å“ªä¸ªå°±æ˜¯æ·»åŠ ä¸€ä¸ªå›è°ƒå‡½æ•°åˆ°äº‹ä»¶å¾ªç¯ä¸­ self.add_callback(assign_thread_identity) è¿™ç§æˆ‘ä»¬å°±å¤§è´¹å‘¨ç« çš„æ‹¿åˆ°äº† io_loop , æ‰€ä»¥æˆ‘ä»¬å†å›åˆ° tornado.netutil.add_accept_handler def add_accept_handler( sock: socket.socket, callback: Callable[[socket.socket, Any], None] ) -> Callable[[], None]: # type: tornado.platform.asyncio.AsyncIOMainLoop(BaseAsyncIOLoop) # type: tornado.platform.asyncio.BaseAsyncIOLoop(IOLoop) # type: tornado.ioloop.IOLoop # IOLoop.current(instance=True) => tornado.ioloop.IOLoop.current io_loop = IOLoop.current() removed = [False] # è¿™é‡Œæˆ‘ä»¬å…ˆçœç•¥accept_handler, ç­‰åˆ°çœŸæ­£ä½¿ç”¨çš„æ—¶å€™å†åˆ†æ def accept_handler(fd: socket.socket, events: int) -> None: pass def remove_handler() -> None: io_loop.remove_handler(sock) removed[0] = True # type: tornado.platform.asyncio.BaseAsyncIOLoop.add_handler # åœ¨è¿™é‡Œæ³¨å†Œäº†ä¸€ä¸ªè¯»äº‹ä»¶ io_loop.add_handler(sock, accept_handler, IOLoop.READ) return remove_handler add_handler tornado.platform.asyncio.BaseAasyncIOLoop.add_handler def add_handler( self, fd: Union[int, _Selectable], handler: Callable[..., None], events: int ) -> None: fd, fileobj = self.split_fd(fd) if fd in self.handlers: raise ValueError(\"fd %s added twice\" % fd) # è¿™é‡Œself.handlersä¸­å­˜å‚¨çš„æ˜¯ä»¥æ–‡ä»¶æè¿°ç¬¦ä¸ºkey, å¥—æ¥å­—å¯¹è±¡å’Œ accept_handler ç»„æˆçš„å…ƒç¥–ä¸ºvalueçš„dict self.handlers[fd] = (fileobj, handler) if events & IOLoop.READ: # type: asyncio.selector_evnets.add_reader # æ·»åŠ ä¸€ä¸ªè¯»äº‹ä»¶çš„å›è°ƒ self.selector_loop.add_reader(fd, self._handle_events, fd, IOLoop.READ) self.readers.add(fd) if events & IOLoop.WRITE: self.selector_loop.add_writer(fd, self._handle_events, fd, IOLoop.WRITE) self.writers.add(fd) asyncio.selector_events.add_reader def add_reader(self, fd, callback, *args): self._ensure_fd_no_transport(fd) # callback: tornado.platform.asyncio.BaseAsyncIOLoop._handle_events # type: asyncio.selector_events.BaseSelectorEventLoop._add_reader return self._add_reader(fd, callback, *args) asyncio.selector_events.BaseSelectorEventLoop._add_reader def _add_reader(self, fd, callback, *args): self._check_closed() handle = events.Handle(callback, args, self) try: key = self._selector.get_key(fd) except KeyError: # self._selectoræ˜¯ä¸€ä¸ªå¤šè·¯å¤ç”¨å™¨, å› ä¸ºæˆ‘ä»¬ä¸»è¦æ˜¯åœ¨Linuxä¸Šè¿è¡Œ # æ‰€ä»¥ type: selectors.EpollSelector # åœ¨Macä¸Šä½¿ç”¨çš„æ˜¯ selectors.KqueueSelector # è¿™é‡Œä¼šå°†ä¸€ä¸ªè¯»äº‹ä»¶æ³¨å†Œåˆ°IOå¤šè·¯å¤ç”¨å™¨ä¸­ self._selector.register(fd, selectors.EVENT_READ, (handle, None)) else: mask, (reader, writer) = key.events, key.data self._selector.modify(fd, mask | selectors.EVENT_READ, (handle, writer)) if reader is not None: reader.cancel() å®é™…ä¸Š , åˆ°è¿™é‡Œ , æˆ‘ä»¬çš„åˆå§‹åŒ–æµç¨‹å°±å·²ç»å®Œæˆäº† ç„¶åæˆ‘ä»¬è°ƒç”¨ tornado.ioloop.IOLoop.current().start() å¦‚æœå…‰çœ‹ç¤ºä¾‹ , ä½ å¯ä»¥ä¼šç–‘æƒ‘ , æˆ‘ä»€ä¹ˆç°åœ¨åˆè°ƒç”¨ IOLoop.current() , ä¸”æ²¡æœ‰æ˜æ˜¾çš„å°†äº‹ä»¶å¾ªç¯å’Œ Tornado çš„åº”ç”¨ç»‘å®šèµ·æ¥ , æ‰€ä»¥åˆ°è¿™é‡Œä½ åº”è¯¥å°±æ²¡æœ‰ç–‘æƒ‘äº† , å› ä¸ºåœ¨ listen ä¸­ , åšäº†å¤ªå¤šçš„äº‹æƒ…äº† tornado.ioloop.current().start() # type: tornado.platform.asyncio.BaseAsyncIOLoop.start def start(self) -> None: try: old_loop = asyncio.get_event_loop() except (RuntimeError, AssertionError): old_loop = None # type: ignore try: self._setup_logging() # type: asyncio.base_events.BaseEventLoop.run_forever asyncio.set_event_loop(self.asyncio_loop) self.asyncio_loop.run_forever() finally: asyncio.set_event_loop(old_loop) asyncio.base_events.BaseEventLoop.run_forever def run_forever(self): \"\"\"Run until stop() is called.\"\"\" self._check_closed() if self.is_running(): raise RuntimeError('This event loop is already running') if events._get_running_loop() is not None: raise RuntimeError( 'Cannot run the event loop while another loop is running') self._set_coroutine_wrapper(self._debug) self._thread_id = threading.get_ident() if self._asyncgens is not None: old_agen_hooks = sys.get_asyncgen_hooks() sys.set_asyncgen_hooks(firstiter=self._asyncgen_firstiter_hook, finalizer=self._asyncgen_finalizer_hook) try: events._set_running_loop(self) while True: # ä»è¿™é‡Œæ•´ä¸ªçº¿ç¨‹å°±è¿›å…¥äº†æ­»å¾ªç¯å½“ä¸­ # type: asyncio.base_events.BaseEventLoop._run_once # æ¯å½“æœ‰æ–°çš„äº‹ä»¶äº§ç”Ÿæ—¶, _run_onceå°±ä¼šè¢«å¾ªç¯ä¸€æ¬¡ self._run_once() if self._stopping: break finally: self._stopping = False self._thread_id = None events._set_running_loop(None) self._set_coroutine_wrapper(False) if self._asyncgens is not None: sys.set_asyncgen_hooks(*old_agen_hooks) _handle_events åœ¨æˆ‘ä»¬åˆ†æ _run_once ä¹‹å‰ , æˆ‘ä»¬éœ€è¦å…ˆçœ‹ä¸€ä¸‹ _handle_events , å› ä¸ºå®ƒè¿™æ‰æ˜¯äº‹ä»¶å‘ç”Ÿæ—¶çš„å›è°ƒå‡½æ•° tornado.platform.asyncio.BaseAsyncIOLoop._handle_events def _handle_events(self, fd: int, events: int) -> None: # å…¶å®è¿™é‡Œçš„æ“ä½œå¾ˆç®€å•, å°±æ˜¯æ ¹æ®ç›‘å¬çš„æ–‡ä»¶æè¿°ç¬¦, åˆ°handlersä¸­è·å–socketå’Œhandler_func # è¿™é‡Œçš„handler_funcå°±æ˜¯accept_handler, ä¹Ÿå°±æ˜¯æˆ‘ä»¬åœ¨è°ƒç”¨add_accept_handlerçš„æ—¶å€™é‡Œé¢è°ƒç”¨çš„io_loop.add_handler(sock, accept_handler, IOLoop.READ) è¿™é‡Œæ”¾è¿›å»çš„ # æ‰€ä»¥æˆ‘ä»¬åˆ°è¿™é‡Œå¯ä»¥å»çœ‹accept_handleräº† fileobj, handler_func = self.handlers[fd] handler_func(fileobj, events) accept_handler # type: tornado.tcpserver.TCPServer._handle_connection callback = self._handle_connection def accept_handler(fd: socket.socket, events: int) -> None: for i in range(_DEFAULT_BACKLOG): if removed[0]: # The socket was probably closed return try: # å…¶å®å°±æ˜¯å½“æœ‰è¿æ¥è¿‡æ¥æ—¶, å°±æ‹¿åˆ°connå’Œaddress, ç„¶åè¿›è¡Œå›è°ƒ # å›è°ƒå°±æ˜¯åœ¨add_socketsçš„æ—¶å€™è®¾ç½®çš„ self._handle_connection connection, address = sock.accept() except BlockingIOError: # EWOULDBLOCK indicates we have accepted every # connection that is available. return except ConnectionAbortedError: # ECONNABORTED indicates that there was a connection # but it was closed while still in the accept queue. # (observed on FreeBSD). continue callback(connection, address) _handle_connection tornado.tcpserver.TCPServer._handle_connection def _handle_connection(self, connection: socket.socket, address: Any) -> None: # æˆ‘ä»¬æŠŠssléƒ¨åˆ†ç›´æ¥ç•¥è¿‡ if self.ssl_options is not None: pass try: if self.ssl_options is not None: stream = SSLIOStream( connection, max_buffer_size=self.max_buffer_size, read_chunk_size=self.read_chunk_size, ) # type: IOStream else: # type: tornado.iostream.IOStream stream = IOStream( connection, max_buffer_size=self.max_buffer_size, read_chunk_size=self.read_chunk_size, ) # type: tornado.httpserver.HTTPServer.handle_stream future = self.handle_stream(stream, address) if future is not None: IOLoop.current().add_future( gen.convert_yielded(future), lambda f: f.result() ) except Exception: app_log.error(\"Error in connection callback\", exc_info=True) tornado.httpserver.HTTPServer.handle_stream def handle_stream(self, stream: iostream.IOStream, address: Tuple) -> None: context = _HTTPRequestContext( stream, address, self.protocol, self.trusted_downstream ) # åˆ›å»ºè¿æ¥å¯¹è±¡ conn = HTTP1ServerConnection(stream, self.conn_params, context) self._connections.add(conn) # type: tornado.http1connection.HTTP1ServerConnection.start_serving # self: tornado.httpserver.HTTPSever ç»§æ‰¿äº† tornado.httputil.HTTPServerConnectionDelegate conn.start_serving(self) tornado.http1connection.HTTP1ServerConnection.start_serving def start_serving(self, delegate: httputil.HTTPServerConnectionDelegate) -> None: assert isinstance(delegate, httputil.HTTPServerConnectionDelegate) # æ„é€ future # delegate HTTPServer # type: tornado.http1connection.HTTP1ServerConnection._server_request_loop # å°† coroutine åŒ…è£…æˆ Task # å®é™…ä¸Šåˆ°è¿™é‡Œä¸€ä¸ªè¯·æ±‚çš„æµç¨‹å°±å·²ç»å®Œæˆäº†, åœ¨self._server_request_loopä¸­ä¸»è¦æ˜¯å¤„ç†è¯·æ±‚çš„ç»†èŠ‚, æˆ‘ä»¬æ”¾åˆ°åé¢çš„ç« èŠ‚ä¸­å†åˆ†æ # è¦æ³¨æ„çš„æ˜¯, è¿™äº›Futureéƒ½è¿˜æ²¡æœ‰çœŸæ­£æ‰§è¡Œ fut = gen.convert_yielded(self._server_request_loop(delegate)) self._serving_future = fut # self.stream.io_loop type: tornado.ioloop.IOLoop.add_future # åœ¨add_futureä¼šè°ƒç”¨Future.add_done_callback type: asyncio.futures.Future # add_done_callbackæ–¹æ³•ä¼šæ ¹æ®å½“å‰Futureçš„çŠ¶æ€æ¥åˆ¤æ–­æ˜¯å¦æ‰§è¡Œ, è€Œæœ€ç»ˆæ‰§è¡Œè¿˜æ˜¯ä½¿ç”¨çš„asyncio.base_events.BaseEventLoop.call_soon # æœ€åå‘¢, call_soonå†è°ƒç”¨_call_soon, å°†å›è°ƒåŒ…è£…æˆevents.Handle, æœ€åappendåˆ°_readyé˜Ÿåˆ—ä¸­ self.stream.io_loop.add_future(fut, lambda f: f.result()) tornado.http1connection.HTTP1ServerConnection._server_request async def _server_request_loop( self, delegate: httputil.HTTPServerConnectionDelegate ) -> None: try: while True: conn = HTTP1Connection(self.stream, False, self.params, self.context) # delegate.start_request type: tornado.httpserver.HTTPServer.start_request request_delegate = delegate.start_request(self, conn) try: ret = await conn.read_response(request_delegate) except ( iostream.StreamClosedError, iostream.UnsatisfiableReadError, asyncio.CancelledError, ): return except _QuietException: # This exception was already logged. conn.close() return except Exception: gen_log.error(\"Uncaught exception\", exc_info=True) conn.close() return if not ret: return # åªè¦æ²¡æœ‰å®Œæˆ, é‚£ä¹ˆæ¯æ¬¡éƒ½ä¼šåˆ‡æ¢ await asyncio.sleep(0) finally: delegate.on_close(self) æ‰€ä»¥åˆ°è¿™é‡Œ , åŸºæœ¬ä¸Šæˆ‘ä»¬å°±å¯ä»¥çŸ¥é“ , æ‰€æœ‰çš„è¯·æ±‚æœ€ç»ˆéƒ½ä¼šè¾¾åˆ° _ready ä¸­ , ç°åœ¨æˆ‘ä»¬å°±å¯ä»¥çœ‹çœ‹æœ€æ ¸å¿ƒçš„ _run_once åˆ°åº•åšäº†ä»€ä¹ˆäº† _run_once asyncio.base_events.BaseEventLoop._run_once def _run_once(self): sched_count = len(self._scheduled) # self._scheduled æ˜¯å…³äºå®šæ—¶ä»»åŠ¡çš„ä¸€äº›å®ç° # å®šæ—¶ä»»åŠ¡åŸºæœ¬ä¸Šæ˜¯é€šè¿‡ asyncio.base_events.BaseEventLoop.call_at å»åšçš„ # è€Œåœ¨call_atä¸­, ä¼šæœ‰ä¸€ä¸ªtimerå®šæ—¶å™¨æ¥æ§åˆ¶ if (sched_count > _MIN_SCHEDULED_TIMER_HANDLES and self._timer_cancelled_count / sched_count > _MIN_CANCELLED_TIMER_HANDLES_FRACTION): # Remove delayed calls that were cancelled if their number # is too high new_scheduled = [] for handle in self._scheduled: if handle._cancelled: handle._scheduled = False else: new_scheduled.append(handle) heapq.heapify(new_scheduled) self._scheduled = new_scheduled self._timer_cancelled_count = 0 else: # Remove delayed calls that were cancelled from head of queue. while self._scheduled and self._scheduled[0]._cancelled: self._timer_cancelled_count -= 1 handle = heapq.heappop(self._scheduled) handle._scheduled = False timeout = None # åˆšå¯åŠ¨è¿›æ¥self._readyå…¶å®æ˜¯æœ‰ä¸œè¥¿çš„, å°±æ˜¯åœ¨listençš„æ—¶å€™æ³¨å†Œçš„ assign_thread_identity å‡½æ•° # å½“å‡†å¤‡å¥½çš„ä»»åŠ¡ä¸­æœ‰ä»»åŠ¡æ—¶, å°±ç›´æ¥æ‰§è¡Œ if self._ready or self._stopping: timeout = 0 # å¦‚æœç°åœ¨éƒ½æ²¡æœ‰, elif self._scheduled: # Compute the desired timeout. when = self._scheduled[0]._when timeout = min(max(0, when - self.time()), MAXIMUM_SELECT_TIMEOUT) if self._debug and timeout != 0: t0 = self.time() event_list = self._selector.select(timeout) dt = self.time() - t0 if dt >= 1.0: level = logging.INFO else: level = logging.DEBUG nevent = len(event_list) if timeout is None: logger.log(level, 'poll took %.3f ms: %s events', dt * 1e3, nevent) elif nevent: logger.log(level, 'poll %.3f ms took %.3f ms: %s events', timeout * 1e3, dt * 1e3, nevent) elif dt >= 1.0: logger.log(level, 'poll %.3f ms took %.3f ms: timeout', timeout * 1e3, dt * 1e3) else: event_list = self._selector.select(timeout) # è¿™ä¸ªæ—¶å€™event_liståªæœ‰[(SelectorKey(fileobj=8, fd=8, events=1, data=(, None)), 1)] # å®ƒæ˜¯åœ¨BaseSelectorEventLoopåˆå§‹åŒ–çš„æ—¶å€™è°ƒç”¨çš„ _make_self_pipeæ–¹æ³•æ”¾è¿›å»çš„ # è€Œ_read_from_selfä¼šä¸€ç›´ç­‰å¾…å¥—æ¥å­—ä¼ è¾“æ•°æ®, å¹¶è¯»å–æ•°æ® # ä½ å¯èƒ½ä¼šæƒ³, æˆ‘ä»¬åœ¨listençš„æ—¶å€™ä¹Ÿæ³¨å†Œäº†ä¸¤ä¸ªå¥—æ¥å­—, ä¸ºä»€ä¹ˆè¿™ä¸ªevent_listæ²¡æœ‰å®ƒä»¬ # è¿™æ˜¯å› ä¸ºç°åœ¨è¿˜æ²¡æœ‰è¿æ¥è¿›æ¥, æ‰€ä»¥ä¸¤ä¸ªäº‹ä»¶éƒ½è¿˜æ²¡æœ‰å‡†å¤‡å¥½ # type: asyncio.selector_events.BaseSelectorEventLoop._process_events self._process_events(event_list) # æˆ‘ä»¬å…ˆçœç•¥ä¸‹é¢çš„éƒ¨åˆ†, çœ‹çœ‹_process_eventsåšäº†ä»€ä¹ˆäº‹æƒ… asyncio.selector_events.BaseSelectorEventLoop._process_events def _process_events(self, event_list): for key, mask in event_list: fileobj, (reader, writer) = key.fileobj, key.data # è¿™é‡Œçš„ key.data å°±æ˜¯æˆ‘ä»¬åœ¨ä¸Šé¢_add_readeræ–¹æ³•ä¸­æ‰€æ³¨å†Œçš„ # è¯»äº‹ä»¶ self._selector.register(fd, selectors.EVENT_READ, (handle, None)) # å†™äº‹ä»¶ self._selector.modify(fd, mask | selectors.EVENT_READ, (handle, writer)) # å…¶ä¸­ handle æ˜¯ events.Handle type: asyncio.events.Handle if mask & selectors.EVENT_READ and reader is not None: if reader._cancelled: self._remove_reader(fileobj) else: # è¿™ä¸ªæ—¶å€™å¹¶ä¸ä¼šçœŸæ­£çš„æ‰§è¡Œè€Œæ˜¯å°†è¿™ä¸ªå›è°ƒå‡½æ•°, æ”¾å…¥ _reday ä¸­ # type: asyncio.base_events.BaseEventLoop._add_callback self._add_callback(reader) if mask & selectors.EVENT_WRITE and writer is not None: if writer._cancelled: self._remove_writer(fileobj) else: self._add_callback(writer) asyncio.base_events.BaseEventLoop._add_callback def _add_callback(self, handle): \"\"\"Add a Handle to _scheduled (TimerHandle) or _ready.\"\"\" assert isinstance(handle, events.Handle), 'A Handle is required here' if handle._cancelled: return assert not isinstance(handle, events.TimerHandle) # ä¹Ÿå°±æ˜¯æˆ‘æ‰€è¯´çš„, ä¼šåŠ å…¥åˆ° _reday é˜Ÿåˆ—ä¸­ # type: asyncio.base_events.BaseEventLoop._ready # _ready : type: collections.queue self._ready.append(handle) æ¥ä¸‹æ¥æˆ‘ä»¬å†å¾€ _process_events ä¸‹é¢çœ‹ end_time = self.time() + self._clock_resolution # å½“æœ‰å®šæ—¶ä»»åŠ¡, ä¸”å®šæ—¶ä»»åŠ¡åˆ°äº†æ‰§è¡Œæ—¶é—´æ—¶, å°±ä¼šå°†å®ƒæ”¾å…¥åˆ°self._readyä¸­å»æ‰§è¡Œ # å®é™…ä¸Šè¿™é‡Œå¤„ç†çš„ä»»åŠ¡, åŸºæœ¬éƒ½æ˜¯TimerHandler while self._scheduled: handle = self._scheduled[0] if handle._when >= end_time: break handle = heapq.heappop(self._scheduled) handle._scheduled = False self._ready.append(handle) ntodo = len(self._ready) for i in range(ntodo): handle = self._ready.popleft() if handle._cancelled: continue # æ— è®ºæˆ‘ä»¬æ˜¯ä¸æ˜¯å‡ºäºDEBUGæ¨¡å¼, éƒ½å°†æ‰§è¡Œhandle._run() # handler type: asyncio.events.Handler._run() if self._debug: try: self._current_handle = handle t0 = self.time() handle._run() dt = self.time() - t0 if dt >= self.slow_callback_duration: logger.warning('Executing %s took %.3f seconds', _format_handle(handle), dt) finally: self._current_handle = None else: handle._run() handle = None # Needed to break cycles when an exception occurs. asyncio.events.Handle._run def _run(self): try: # é‚£ä¹ˆè¿™é‡Œ_callbackå°±ä¸ç”¨åœ¨è¯´äº†, å°±æ˜¯å»æ‰§è¡Œæˆ‘ä»¬_readyé˜Ÿåˆ—ä¸­çš„æ‰€æœ‰ä»»åŠ¡äº† self._callback(*self._args) except Exception as exc: cb = _format_callback_source(self._callback, self._args) msg = 'Exception in callback {}'.format(cb) context = { 'message': msg, 'exception': exc, 'handle': self, } if self._source_traceback: context['source_traceback'] = self._source_traceback # å¦‚æœæ•æ‰åˆ°å¼‚å¸¸äº†, åŒæ ·çš„, è¿˜æ˜¯åŠ å…¥åˆ°äº‹ä»¶å¾ªç¯ä¸­å»æ‰§è¡Œ # type: asyncio.base_events.BaseEventLoop.call_exception_handler self._loop.call_exception_handler(context) self = None # Needed to break cycles when an exception occurs. å› ä¸ºæœ¬æ–‡çš„æ ¸å¿ƒé‡ç‚¹å¹¶ä¸åœ¨ asyncio ä¸Š , æ‰€ä»¥å…³äº asyncio å¹¶æ²¡æœ‰è¿‡å¤šè§£é‡Š é€šè¿‡è¿™ä¸€èŠ‚æºç åˆ†æ , æˆ‘ä»¬å°±å¯ä»¥çŸ¥é“ , åœ¨ Tornado æˆ–è€…è¯´ asyncio ä¸­ , å¼‚æ­¥éé˜»å¡æ¨¡å‹çš„å®ç° , å®é™…ä¸Šåªæ˜¯åº”ç”¨å±‚çš„å¼‚æ­¥éé˜»å¡ , åœ¨ç³»ç»Ÿå±‚è¿˜æ˜¯ä½¿ç”¨çš„IOå¤šè·¯å¤ç”¨ä¹Ÿå°±æ˜¯åŒæ­¥IOå»å®ç°çš„ ä¸” callback å¦‚æœè®¡ç®—è¿‡ä¹… , åŒæ ·ä¹Ÿä¼šé€ æˆæ•´ä¸ªçº¿ç¨‹é˜»å¡ , æ‰€ä»¥å¦‚æœè®¡ç®—è¿‡é•¿çš„å‡½æ•° , å¯ä»¥åˆ†æˆå¤šä¸ªå‡½æ•° , æˆ–è€…åˆ©ç”¨çº¿ç¨‹æ± æ¥å¤„ç† "}}